diff -ruN .gitignore .gitignore
--- .gitignore	1970-01-01 01:00:00
+++ .gitignore	2023-11-23 10:04:57
@@ -0,0 +1,2 @@
+*
+!.gitignore
diff -ruN protocol/libraries/logic/GenericLogic.sol protocol/libraries/logic/GenericLogic.sol
--- protocol/libraries/logic/GenericLogic.sol	2023-12-06 11:44:43
+++ protocol/libraries/logic/GenericLogic.sol	2023-12-06 11:44:45
@@ -66,7 +66,7 @@
     mapping(uint256 => address) storage reservesList,
     mapping(uint8 => DataTypes.EModeCategory) storage eModeCategories,
     DataTypes.CalculateUserAccountDataParams memory params
-  ) internal view returns (uint256, uint256, uint256, uint256, uint256, bool) {
+  ) external view returns (uint256, uint256, uint256, uint256, uint256, bool) { // munged to external
     if (params.userConfig.isEmpty()) {
       return (0, 0, 0, 0, type(uint256).max, false);
     }
diff -ruN protocol/libraries/logic/ReserveLogic.sol protocol/libraries/logic/ReserveLogic.sol
--- protocol/libraries/logic/ReserveLogic.sol	2023-11-29 16:23:16
+++ protocol/libraries/logic/ReserveLogic.sol	2023-11-30 16:03:36
@@ -14,6 +14,10 @@
 import {DataTypes} from '../types/DataTypes.sol';
 import {SafeCast} from '../../../dependencies/openzeppelin/contracts/SafeCast.sol';
 
+interface ICVL {
+  function incrementCounter() external view returns(bool);
+}
+
 /**
  * @title ReserveLogic library
  * @author Aave
@@ -100,6 +104,7 @@
       return;
     }
 
+    ICVL(address(0xdeadc0de)).incrementCounter();
     _updateIndexes(reserve, reserveCache);
     _accrueToTreasury(reserve, reserveCache);
 
@@ -122,6 +127,7 @@
   ) internal returns (uint256) {
     //next liquidity index is calculated this way: `((amount / totalLiquidity) + 1) * liquidityIndex`
     //division `amount / totalLiquidity` done in ray for precision
+    ICVL(address(0xdeadc0de)).incrementCounter();
     uint256 result = (amount.wadToRay().rayDiv(totalLiquidity.wadToRay()) + WadRayMath.RAY).rayMul(
       reserve.liquidityIndex
     );
diff -ruN protocol/tokenization/AToken.sol protocol/tokenization/AToken.sol
--- protocol/tokenization/AToken.sol	2023-09-12 14:30:00
+++ protocol/tokenization/AToken.sol	2023-12-05 09:32:53
@@ -70,16 +70,16 @@
 
     _domainSeparator = _calculateDomainSeparator();
 
-    emit Initialized(
-      underlyingAsset,
-      address(POOL),
-      treasury,
-      address(incentivesController),
-      aTokenDecimals,
-      aTokenName,
-      aTokenSymbol,
-      params
-    );
+    // emit Initialized(
+    //   underlyingAsset,
+    //   address(POOL),
+    //   treasury,
+    //   address(incentivesController),
+    //   aTokenDecimals,
+    //   aTokenName,
+    //   aTokenSymbol,
+    //   params
+    // );
   }
 
   /// @inheritdoc IAToken
@@ -129,6 +129,13 @@
     address user
   ) public view virtual override(IncentivizedERC20, IERC20) returns (uint256) {
     return super.balanceOf(user).rayMul(POOL.getReserveNormalizedIncome(_underlyingAsset));
+  }
+
+  // munged by Certora
+  function superBalance(
+    address user
+  ) public view returns (uint256) {
+      return super.balanceOf(user);
   }
 
   /// @inheritdoc IERC20
diff -ruN protocol/tokenization/AToken.sol.orig protocol/tokenization/AToken.sol.orig
--- protocol/tokenization/AToken.sol.orig	1970-01-01 01:00:00
+++ protocol/tokenization/AToken.sol.orig	2023-11-23 10:04:57
@@ -0,0 +1,256 @@
+// SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.10;
+
+import {IERC20} from '../../dependencies/openzeppelin/contracts/IERC20.sol';
+import {GPv2SafeERC20} from '../../dependencies/gnosis/contracts/GPv2SafeERC20.sol';
+import {SafeCast} from '../../dependencies/openzeppelin/contracts/SafeCast.sol';
+import {VersionedInitializable} from '../libraries/aave-upgradeability/VersionedInitializable.sol';
+import {Errors} from '../libraries/helpers/Errors.sol';
+import {WadRayMath} from '../libraries/math/WadRayMath.sol';
+import {IPool} from '../../interfaces/IPool.sol';
+import {IAToken} from '../../interfaces/IAToken.sol';
+import {IAaveIncentivesController} from '../../interfaces/IAaveIncentivesController.sol';
+import {IInitializableAToken} from '../../interfaces/IInitializableAToken.sol';
+import {ScaledBalanceTokenBase} from './base/ScaledBalanceTokenBase.sol';
+import {IncentivizedERC20} from './base/IncentivizedERC20.sol';
+import {EIP712Base} from './base/EIP712Base.sol';
+
+/**
+ * @title Aave ERC20 AToken
+ * @author Aave
+ * @notice Implementation of the interest bearing token for the Aave protocol
+ */
+contract AToken is VersionedInitializable, ScaledBalanceTokenBase, EIP712Base, IAToken {
+  using WadRayMath for uint256;
+  using SafeCast for uint256;
+  using GPv2SafeERC20 for IERC20;
+
+  bytes32 public constant PERMIT_TYPEHASH =
+    keccak256('Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)');
+
+  uint256 public constant ATOKEN_REVISION = 0x1;
+
+  address internal _treasury;
+  address internal _underlyingAsset;
+
+  /// @inheritdoc VersionedInitializable
+  function getRevision() internal pure virtual override returns (uint256) {
+    return ATOKEN_REVISION;
+  }
+
+  /**
+   * @dev Constructor.
+   * @param pool The address of the Pool contract
+   */
+  constructor(
+    IPool pool
+  ) ScaledBalanceTokenBase(pool, 'ATOKEN_IMPL', 'ATOKEN_IMPL', 0) EIP712Base() {
+    // Intentionally left blank
+  }
+
+  /// @inheritdoc IInitializableAToken
+  function initialize(
+    IPool initializingPool,
+    address treasury,
+    address underlyingAsset,
+    IAaveIncentivesController incentivesController,
+    uint8 aTokenDecimals,
+    string calldata aTokenName,
+    string calldata aTokenSymbol,
+    bytes calldata params
+  ) public virtual override initializer {
+    require(initializingPool == POOL, Errors.POOL_ADDRESSES_DO_NOT_MATCH);
+    _setName(aTokenName);
+    _setSymbol(aTokenSymbol);
+    _setDecimals(aTokenDecimals);
+
+    _treasury = treasury;
+    _underlyingAsset = underlyingAsset;
+    _incentivesController = incentivesController;
+
+    _domainSeparator = _calculateDomainSeparator();
+
+    emit Initialized(
+      underlyingAsset,
+      address(POOL),
+      treasury,
+      address(incentivesController),
+      aTokenDecimals,
+      aTokenName,
+      aTokenSymbol,
+      params
+    );
+  }
+
+  /// @inheritdoc IAToken
+  function mint(
+    address caller,
+    address onBehalfOf,
+    uint256 amount,
+    uint256 index
+  ) external virtual override onlyPool returns (bool) {
+    return _mintScaled(caller, onBehalfOf, amount, index);
+  }
+
+  /// @inheritdoc IAToken
+  function burn(
+    address from,
+    address receiverOfUnderlying,
+    uint256 amount,
+    uint256 index
+  ) external virtual override onlyPool {
+    _burnScaled(from, receiverOfUnderlying, amount, index);
+    if (receiverOfUnderlying != address(this)) {
+      IERC20(_underlyingAsset).safeTransfer(receiverOfUnderlying, amount);
+    }
+  }
+
+  /// @inheritdoc IAToken
+  function mintToTreasury(uint256 amount, uint256 index) external virtual override onlyPool {
+    if (amount == 0) {
+      return;
+    }
+    _mintScaled(address(POOL), _treasury, amount, index);
+  }
+
+  /// @inheritdoc IAToken
+  function transferOnLiquidation(
+    address from,
+    address to,
+    uint256 value
+  ) external virtual override onlyPool {
+    // Being a normal transfer, the Transfer() and BalanceTransfer() are emitted
+    // so no need to emit a specific event here
+    _transfer(from, to, value, false);
+  }
+
+  /// @inheritdoc IERC20
+  function balanceOf(
+    address user
+  ) public view virtual override(IncentivizedERC20, IERC20) returns (uint256) {
+    return super.balanceOf(user).rayMul(POOL.getReserveNormalizedIncome(_underlyingAsset));
+  }
+
+  /// @inheritdoc IERC20
+  function totalSupply() public view virtual override(IncentivizedERC20, IERC20) returns (uint256) {
+    uint256 currentSupplyScaled = super.totalSupply();
+
+    if (currentSupplyScaled == 0) {
+      return 0;
+    }
+
+    return currentSupplyScaled.rayMul(POOL.getReserveNormalizedIncome(_underlyingAsset));
+  }
+
+  /// @inheritdoc IAToken
+  function RESERVE_TREASURY_ADDRESS() external view override returns (address) {
+    return _treasury;
+  }
+
+  /// @inheritdoc IAToken
+  function UNDERLYING_ASSET_ADDRESS() external view override returns (address) {
+    return _underlyingAsset;
+  }
+
+  /// @inheritdoc IAToken
+  function transferUnderlyingTo(address target, uint256 amount) external virtual override onlyPool {
+    IERC20(_underlyingAsset).safeTransfer(target, amount);
+  }
+
+  /// @inheritdoc IAToken
+  function handleRepayment(
+    address user,
+    address onBehalfOf,
+    uint256 amount
+  ) external virtual override onlyPool {
+    // Intentionally left blank
+  }
+
+  /// @inheritdoc IAToken
+  function permit(
+    address owner,
+    address spender,
+    uint256 value,
+    uint256 deadline,
+    uint8 v,
+    bytes32 r,
+    bytes32 s
+  ) external override {
+    require(owner != address(0), Errors.ZERO_ADDRESS_NOT_VALID);
+    //solium-disable-next-line
+    require(block.timestamp <= deadline, Errors.INVALID_EXPIRATION);
+    uint256 currentValidNonce = _nonces[owner];
+    bytes32 digest = keccak256(
+      abi.encodePacked(
+        '\x19\x01',
+        DOMAIN_SEPARATOR(),
+        keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, currentValidNonce, deadline))
+      )
+    );
+    require(owner == ecrecover(digest, v, r, s), Errors.INVALID_SIGNATURE);
+    _nonces[owner] = currentValidNonce + 1;
+    _approve(owner, spender, value);
+  }
+
+  /**
+   * @notice Transfers the aTokens between two users. Validates the transfer
+   * (ie checks for valid HF after the transfer) if required
+   * @param from The source address
+   * @param to The destination address
+   * @param amount The amount getting transferred
+   * @param validate True if the transfer needs to be validated, false otherwise
+   */
+  function _transfer(address from, address to, uint256 amount, bool validate) internal virtual {
+    address underlyingAsset = _underlyingAsset;
+
+    uint256 index = POOL.getReserveNormalizedIncome(underlyingAsset);
+
+    uint256 fromBalanceBefore = super.balanceOf(from).rayMul(index);
+    uint256 toBalanceBefore = super.balanceOf(to).rayMul(index);
+
+    super._transfer(from, to, amount, index);
+
+    if (validate) {
+      POOL.finalizeTransfer(underlyingAsset, from, to, amount, fromBalanceBefore, toBalanceBefore);
+    }
+
+    emit BalanceTransfer(from, to, amount.rayDiv(index), index);
+  }
+
+  /**
+   * @notice Overrides the parent _transfer to force validated transfer() and transferFrom()
+   * @param from The source address
+   * @param to The destination address
+   * @param amount The amount getting transferred
+   */
+  function _transfer(address from, address to, uint128 amount) internal virtual override {
+    _transfer(from, to, amount, true);
+  }
+
+  /**
+   * @dev Overrides the base function to fully implement IAToken
+   * @dev see `EIP712Base.DOMAIN_SEPARATOR()` for more detailed documentation
+   */
+  function DOMAIN_SEPARATOR() public view override(IAToken, EIP712Base) returns (bytes32) {
+    return super.DOMAIN_SEPARATOR();
+  }
+
+  /**
+   * @dev Overrides the base function to fully implement IAToken
+   * @dev see `EIP712Base.nonces()` for more detailed documentation
+   */
+  function nonces(address owner) public view override(IAToken, EIP712Base) returns (uint256) {
+    return super.nonces(owner);
+  }
+
+  /// @inheritdoc EIP712Base
+  function _EIP712BaseId() internal view override returns (string memory) {
+    return name();
+  }
+
+  /// @inheritdoc IAToken
+  function rescueTokens(address token, address to, uint256 amount) external override onlyPoolAdmin {
+    require(token != _underlyingAsset, Errors.UNDERLYING_CANNOT_BE_RESCUED);
+    IERC20(token).safeTransfer(to, amount);
+  }
+}
diff -ruN protocol/tokenization/StableDebtToken.sol protocol/tokenization/StableDebtToken.sol
--- protocol/tokenization/StableDebtToken.sol	2023-09-12 14:30:00
+++ protocol/tokenization/StableDebtToken.sol	2023-11-23 10:04:57
@@ -306,7 +306,7 @@
    * @param avgRate The average rate at which the total supply increases
    * @return The debt balance of the user since the last burn/mint action
    */
-  function _calcTotalSupply(uint256 avgRate) internal view returns (uint256) {
+  function _calcTotalSupply(uint256 avgRate) internal virtual view returns (uint256) {
     uint256 principalSupply = super.totalSupply();
 
     if (principalSupply == 0) {
diff -ruN protocol/tokenization/StableDebtToken.sol.orig protocol/tokenization/StableDebtToken.sol.orig
--- protocol/tokenization/StableDebtToken.sol.orig	1970-01-01 01:00:00
+++ protocol/tokenization/StableDebtToken.sol.orig	2023-11-23 10:04:57
@@ -0,0 +1,388 @@
+// SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.10;
+
+import {IERC20} from '../../dependencies/openzeppelin/contracts/IERC20.sol';
+import {VersionedInitializable} from '../libraries/aave-upgradeability/VersionedInitializable.sol';
+import {MathUtils} from '../libraries/math/MathUtils.sol';
+import {WadRayMath} from '../libraries/math/WadRayMath.sol';
+import {Errors} from '../libraries/helpers/Errors.sol';
+import {IAaveIncentivesController} from '../../interfaces/IAaveIncentivesController.sol';
+import {IInitializableDebtToken} from '../../interfaces/IInitializableDebtToken.sol';
+import {IStableDebtToken} from '../../interfaces/IStableDebtToken.sol';
+import {IPool} from '../../interfaces/IPool.sol';
+import {EIP712Base} from './base/EIP712Base.sol';
+import {DebtTokenBase} from './base/DebtTokenBase.sol';
+import {IncentivizedERC20} from './base/IncentivizedERC20.sol';
+import {SafeCast} from '../../dependencies/openzeppelin/contracts/SafeCast.sol';
+
+/**
+ * @title StableDebtToken
+ * @author Aave
+ * @notice Implements a stable debt token to track the borrowing positions of users
+ * at stable rate mode
+ * @dev Transfer and approve functionalities are disabled since its a non-transferable token
+ */
+contract StableDebtToken is DebtTokenBase, IncentivizedERC20, IStableDebtToken {
+  using WadRayMath for uint256;
+  using SafeCast for uint256;
+
+  uint256 public constant DEBT_TOKEN_REVISION = 0x1;
+
+  // Map of users address and the timestamp of their last update (userAddress => lastUpdateTimestamp)
+  mapping(address => uint40) internal _timestamps;
+
+  uint128 internal _avgStableRate;
+
+  // Timestamp of the last update of the total supply
+  uint40 internal _totalSupplyTimestamp;
+
+  /**
+   * @dev Constructor.
+   * @param pool The address of the Pool contract
+   */
+  constructor(
+    IPool pool
+  ) DebtTokenBase() IncentivizedERC20(pool, 'STABLE_DEBT_TOKEN_IMPL', 'STABLE_DEBT_TOKEN_IMPL', 0) {
+    // Intentionally left blank
+  }
+
+  /// @inheritdoc IInitializableDebtToken
+  function initialize(
+    IPool initializingPool,
+    address underlyingAsset,
+    IAaveIncentivesController incentivesController,
+    uint8 debtTokenDecimals,
+    string memory debtTokenName,
+    string memory debtTokenSymbol,
+    bytes calldata params
+  ) external override initializer {
+    require(initializingPool == POOL, Errors.POOL_ADDRESSES_DO_NOT_MATCH);
+    _setName(debtTokenName);
+    _setSymbol(debtTokenSymbol);
+    _setDecimals(debtTokenDecimals);
+
+    _underlyingAsset = underlyingAsset;
+    _incentivesController = incentivesController;
+
+    _domainSeparator = _calculateDomainSeparator();
+
+    emit Initialized(
+      underlyingAsset,
+      address(POOL),
+      address(incentivesController),
+      debtTokenDecimals,
+      debtTokenName,
+      debtTokenSymbol,
+      params
+    );
+  }
+
+  /// @inheritdoc VersionedInitializable
+  function getRevision() internal pure virtual override returns (uint256) {
+    return DEBT_TOKEN_REVISION;
+  }
+
+  /// @inheritdoc IStableDebtToken
+  function getAverageStableRate() external view virtual override returns (uint256) {
+    return _avgStableRate;
+  }
+
+  /// @inheritdoc IStableDebtToken
+  function getUserLastUpdated(address user) external view virtual override returns (uint40) {
+    return _timestamps[user];
+  }
+
+  /// @inheritdoc IStableDebtToken
+  function getUserStableRate(address user) external view virtual override returns (uint256) {
+    return _userState[user].additionalData;
+  }
+
+  /// @inheritdoc IERC20
+  function balanceOf(address account) public view virtual override returns (uint256) {
+    uint256 accountBalance = super.balanceOf(account);
+    uint256 stableRate = _userState[account].additionalData;
+    if (accountBalance == 0) {
+      return 0;
+    }
+    uint256 cumulatedInterest = MathUtils.calculateCompoundedInterest(
+      stableRate,
+      _timestamps[account]
+    );
+    return accountBalance.rayMul(cumulatedInterest);
+  }
+
+  struct MintLocalVars {
+    uint256 previousSupply;
+    uint256 nextSupply;
+    uint256 amountInRay;
+    uint256 currentStableRate;
+    uint256 nextStableRate;
+    uint256 currentAvgStableRate;
+  }
+
+  /// @inheritdoc IStableDebtToken
+  function mint(
+    address user,
+    address onBehalfOf,
+    uint256 amount,
+    uint256 rate
+  ) external virtual override onlyPool returns (bool, uint256, uint256) {
+    MintLocalVars memory vars;
+
+    if (user != onBehalfOf) {
+      _decreaseBorrowAllowance(onBehalfOf, user, amount);
+    }
+
+    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(onBehalfOf);
+
+    vars.previousSupply = totalSupply();
+    vars.currentAvgStableRate = _avgStableRate;
+    vars.nextSupply = _totalSupply = vars.previousSupply + amount;
+
+    vars.amountInRay = amount.wadToRay();
+
+    vars.currentStableRate = _userState[onBehalfOf].additionalData;
+    vars.nextStableRate = (vars.currentStableRate.rayMul(currentBalance.wadToRay()) +
+      vars.amountInRay.rayMul(rate)).rayDiv((currentBalance + amount).wadToRay());
+
+    _userState[onBehalfOf].additionalData = vars.nextStableRate.toUint128();
+
+    //solium-disable-next-line
+    _totalSupplyTimestamp = _timestamps[onBehalfOf] = uint40(block.timestamp);
+
+    // Calculates the updated average stable rate
+    vars.currentAvgStableRate = _avgStableRate = (
+      (vars.currentAvgStableRate.rayMul(vars.previousSupply.wadToRay()) +
+        rate.rayMul(vars.amountInRay)).rayDiv(vars.nextSupply.wadToRay())
+    ).toUint128();
+
+    uint256 amountToMint = amount + balanceIncrease;
+    _mint(onBehalfOf, amountToMint, vars.previousSupply);
+
+    emit Transfer(address(0), onBehalfOf, amountToMint);
+    emit Mint(
+      user,
+      onBehalfOf,
+      amountToMint,
+      currentBalance,
+      balanceIncrease,
+      vars.nextStableRate,
+      vars.currentAvgStableRate,
+      vars.nextSupply
+    );
+
+    return (currentBalance == 0, vars.nextSupply, vars.currentAvgStableRate);
+  }
+
+  /// @inheritdoc IStableDebtToken
+  function burn(
+    address from,
+    uint256 amount
+  ) external virtual override onlyPool returns (uint256, uint256) {
+    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(from);
+
+    uint256 previousSupply = totalSupply();
+    uint256 nextAvgStableRate = 0;
+    uint256 nextSupply = 0;
+    uint256 userStableRate = _userState[from].additionalData;
+
+    // Since the total supply and each single user debt accrue separately,
+    // there might be accumulation errors so that the last borrower repaying
+    // might actually try to repay more than the available debt supply.
+    // In this case we simply set the total supply and the avg stable rate to 0
+    if (previousSupply <= amount) {
+      _avgStableRate = 0;
+      _totalSupply = 0;
+    } else {
+      nextSupply = _totalSupply = previousSupply - amount;
+      uint256 firstTerm = uint256(_avgStableRate).rayMul(previousSupply.wadToRay());
+      uint256 secondTerm = userStableRate.rayMul(amount.wadToRay());
+
+      // For the same reason described above, when the last user is repaying it might
+      // happen that user rate * user balance > avg rate * total supply. In that case,
+      // we simply set the avg rate to 0
+      if (secondTerm >= firstTerm) {
+        nextAvgStableRate = _totalSupply = _avgStableRate = 0;
+      } else {
+        nextAvgStableRate = _avgStableRate = (
+          (firstTerm - secondTerm).rayDiv(nextSupply.wadToRay())
+        ).toUint128();
+      }
+    }
+
+    if (amount == currentBalance) {
+      _userState[from].additionalData = 0;
+      _timestamps[from] = 0;
+    } else {
+      //solium-disable-next-line
+      _timestamps[from] = uint40(block.timestamp);
+    }
+    //solium-disable-next-line
+    _totalSupplyTimestamp = uint40(block.timestamp);
+
+    if (balanceIncrease > amount) {
+      uint256 amountToMint = balanceIncrease - amount;
+      _mint(from, amountToMint, previousSupply);
+      emit Transfer(address(0), from, amountToMint);
+      emit Mint(
+        from,
+        from,
+        amountToMint,
+        currentBalance,
+        balanceIncrease,
+        userStableRate,
+        nextAvgStableRate,
+        nextSupply
+      );
+    } else {
+      uint256 amountToBurn = amount - balanceIncrease;
+      _burn(from, amountToBurn, previousSupply);
+      emit Transfer(from, address(0), amountToBurn);
+      emit Burn(from, amountToBurn, currentBalance, balanceIncrease, nextAvgStableRate, nextSupply);
+    }
+
+    return (nextSupply, nextAvgStableRate);
+  }
+
+  /**
+   * @notice Calculates the increase in balance since the last user interaction
+   * @param user The address of the user for which the interest is being accumulated
+   * @return The previous principal balance
+   * @return The new principal balance
+   * @return The balance increase
+   */
+  function _calculateBalanceIncrease(
+    address user
+  ) internal view returns (uint256, uint256, uint256) {
+    uint256 previousPrincipalBalance = super.balanceOf(user);
+
+    if (previousPrincipalBalance == 0) {
+      return (0, 0, 0);
+    }
+
+    uint256 newPrincipalBalance = balanceOf(user);
+
+    return (
+      previousPrincipalBalance,
+      newPrincipalBalance,
+      newPrincipalBalance - previousPrincipalBalance
+    );
+  }
+
+  /// @inheritdoc IStableDebtToken
+  function getSupplyData() external view override returns (uint256, uint256, uint256, uint40) {
+    uint256 avgRate = _avgStableRate;
+    return (super.totalSupply(), _calcTotalSupply(avgRate), avgRate, _totalSupplyTimestamp);
+  }
+
+  /// @inheritdoc IStableDebtToken
+  function getTotalSupplyAndAvgRate() external view override returns (uint256, uint256) {
+    uint256 avgRate = _avgStableRate;
+    return (_calcTotalSupply(avgRate), avgRate);
+  }
+
+  /// @inheritdoc IERC20
+  function totalSupply() public view virtual override returns (uint256) {
+    return _calcTotalSupply(_avgStableRate);
+  }
+
+  /// @inheritdoc IStableDebtToken
+  function getTotalSupplyLastUpdated() external view override returns (uint40) {
+    return _totalSupplyTimestamp;
+  }
+
+  /// @inheritdoc IStableDebtToken
+  function principalBalanceOf(address user) external view virtual override returns (uint256) {
+    return super.balanceOf(user);
+  }
+
+  /// @inheritdoc IStableDebtToken
+  function UNDERLYING_ASSET_ADDRESS() external view override returns (address) {
+    return _underlyingAsset;
+  }
+
+  /**
+   * @notice Calculates the total supply
+   * @param avgRate The average rate at which the total supply increases
+   * @return The debt balance of the user since the last burn/mint action
+   */
+  function _calcTotalSupply(uint256 avgRate) internal view returns (uint256) {
+    uint256 principalSupply = super.totalSupply();
+
+    if (principalSupply == 0) {
+      return 0;
+    }
+
+    uint256 cumulatedInterest = MathUtils.calculateCompoundedInterest(
+      avgRate,
+      _totalSupplyTimestamp
+    );
+
+    return principalSupply.rayMul(cumulatedInterest);
+  }
+
+  /**
+   * @notice Mints stable debt tokens to a user
+   * @param account The account receiving the debt tokens
+   * @param amount The amount being minted
+   * @param oldTotalSupply The total supply before the minting event
+   */
+  function _mint(address account, uint256 amount, uint256 oldTotalSupply) internal {
+    uint128 castAmount = amount.toUint128();
+    uint128 oldAccountBalance = _userState[account].balance;
+    _userState[account].balance = oldAccountBalance + castAmount;
+
+    if (address(_incentivesController) != address(0)) {
+      _incentivesController.handleAction(account, oldTotalSupply, oldAccountBalance);
+    }
+  }
+
+  /**
+   * @notice Burns stable debt tokens of a user
+   * @param account The user getting his debt burned
+   * @param amount The amount being burned
+   * @param oldTotalSupply The total supply before the burning event
+   */
+  function _burn(address account, uint256 amount, uint256 oldTotalSupply) internal {
+    uint128 castAmount = amount.toUint128();
+    uint128 oldAccountBalance = _userState[account].balance;
+    _userState[account].balance = oldAccountBalance - castAmount;
+
+    if (address(_incentivesController) != address(0)) {
+      _incentivesController.handleAction(account, oldTotalSupply, oldAccountBalance);
+    }
+  }
+
+  /// @inheritdoc EIP712Base
+  function _EIP712BaseId() internal view override returns (string memory) {
+    return name();
+  }
+
+  /**
+   * @dev Being non transferrable, the debt token does not implement any of the
+   * standard ERC20 functions for transfer and allowance.
+   */
+  function transfer(address, uint256) external virtual override returns (bool) {
+    revert(Errors.OPERATION_NOT_SUPPORTED);
+  }
+
+  function allowance(address, address) external view virtual override returns (uint256) {
+    revert(Errors.OPERATION_NOT_SUPPORTED);
+  }
+
+  function approve(address, uint256) external virtual override returns (bool) {
+    revert(Errors.OPERATION_NOT_SUPPORTED);
+  }
+
+  function transferFrom(address, address, uint256) external virtual override returns (bool) {
+    revert(Errors.OPERATION_NOT_SUPPORTED);
+  }
+
+  function increaseAllowance(address, uint256) external virtual override returns (bool) {
+    revert(Errors.OPERATION_NOT_SUPPORTED);
+  }
+
+  function decreaseAllowance(address, uint256) external virtual override returns (bool) {
+    revert(Errors.OPERATION_NOT_SUPPORTED);
+  }
+}
