diff -ruN .gitignore .gitignore
--- .gitignore	1970-01-01 01:00:00
+++ .gitignore	2023-11-20 14:47:29
@@ -0,0 +1 @@
+*
\ No newline at end of file
diff -ruN protocol/libraries/configuration/ReserveConfiguration.sol protocol/libraries/configuration/ReserveConfiguration.sol
--- protocol/libraries/configuration/ReserveConfiguration.sol	2023-11-14 21:14:54
+++ protocol/libraries/configuration/ReserveConfiguration.sol	2023-11-15 18:37:22
@@ -10,46 +10,6 @@
  * @notice Implements the bitmap logic to handle the reserve configuration
  */
 library ReserveConfiguration {
-  uint256 internal constant LTV_MASK =                       0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000; // prettier-ignore
-  uint256 internal constant LIQUIDATION_THRESHOLD_MASK =     0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFF; // prettier-ignore
-  uint256 internal constant LIQUIDATION_BONUS_MASK =         0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFF; // prettier-ignore
-  uint256 internal constant DECIMALS_MASK =                  0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00FFFFFFFFFFFF; // prettier-ignore
-  uint256 internal constant ACTIVE_MASK =                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFF; // prettier-ignore
-  uint256 internal constant FROZEN_MASK =                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFFFFFFFFFFFFFF; // prettier-ignore
-  uint256 internal constant BORROWING_MASK =                 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFBFFFFFFFFFFFFFF; // prettier-ignore
-  uint256 internal constant STABLE_BORROWING_MASK =          0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFFFFF; // prettier-ignore
-  uint256 internal constant PAUSED_MASK =                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFF; // prettier-ignore
-  uint256 internal constant BORROWABLE_IN_ISOLATION_MASK =   0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFFFFFFFFFFFFFFF; // prettier-ignore
-  uint256 internal constant SILOED_BORROWING_MASK =          0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFBFFFFFFFFFFFFFFF; // prettier-ignore
-  uint256 internal constant FLASHLOAN_ENABLED_MASK =         0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFFFFFF; // prettier-ignore
-  uint256 internal constant RESERVE_FACTOR_MASK =            0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFFFFFFFFFF; // prettier-ignore
-  uint256 internal constant BORROW_CAP_MASK =                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000FFFFFFFFFFFFFFFFFFFF; // prettier-ignore
-  uint256 internal constant SUPPLY_CAP_MASK =                0xFFFFFFFFFFFFFFFFFFFFFFFFFF000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore
-  uint256 internal constant LIQUIDATION_PROTOCOL_FEE_MASK =  0xFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore
-  uint256 internal constant EMODE_CATEGORY_MASK =            0xFFFFFFFFFFFFFFFFFFFF00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore
-  uint256 internal constant UNBACKED_MINT_CAP_MASK =         0xFFFFFFFFFFF000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore
-  uint256 internal constant DEBT_CEILING_MASK =              0xF0000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore
-
-  /// @dev For the LTV, the start bit is 0 (up to 15), hence no bitshifting is needed
-  uint256 internal constant LIQUIDATION_THRESHOLD_START_BIT_POSITION = 16;
-  uint256 internal constant LIQUIDATION_BONUS_START_BIT_POSITION = 32;
-  uint256 internal constant RESERVE_DECIMALS_START_BIT_POSITION = 48;
-  uint256 internal constant IS_ACTIVE_START_BIT_POSITION = 56;
-  uint256 internal constant IS_FROZEN_START_BIT_POSITION = 57;
-  uint256 internal constant BORROWING_ENABLED_START_BIT_POSITION = 58;
-  uint256 internal constant STABLE_BORROWING_ENABLED_START_BIT_POSITION = 59;
-  uint256 internal constant IS_PAUSED_START_BIT_POSITION = 60;
-  uint256 internal constant BORROWABLE_IN_ISOLATION_START_BIT_POSITION = 61;
-  uint256 internal constant SILOED_BORROWING_START_BIT_POSITION = 62;
-  uint256 internal constant FLASHLOAN_ENABLED_START_BIT_POSITION = 63;
-  uint256 internal constant RESERVE_FACTOR_START_BIT_POSITION = 64;
-  uint256 internal constant BORROW_CAP_START_BIT_POSITION = 80;
-  uint256 internal constant SUPPLY_CAP_START_BIT_POSITION = 116;
-  uint256 internal constant LIQUIDATION_PROTOCOL_FEE_START_BIT_POSITION = 152;
-  uint256 internal constant EMODE_CATEGORY_START_BIT_POSITION = 168;
-  uint256 internal constant UNBACKED_MINT_CAP_START_BIT_POSITION = 176;
-  uint256 internal constant DEBT_CEILING_START_BIT_POSITION = 212;
-
   uint256 internal constant MAX_VALID_LTV = 65535;
   uint256 internal constant MAX_VALID_LIQUIDATION_THRESHOLD = 65535;
   uint256 internal constant MAX_VALID_LIQUIDATION_BONUS = 65535;
@@ -63,7 +23,7 @@
   uint256 internal constant MAX_VALID_DEBT_CEILING = 1099511627775;
 
   uint256 public constant DEBT_CEILING_DECIMALS = 2;
-  uint16 public constant MAX_RESERVES_COUNT = 128;
+  uint16 public constant MAX_RESERVES_COUNT = 3;
 
   /**
    * @notice Sets the Loan to Value of the reserve
@@ -72,8 +32,7 @@
    */
   function setLtv(DataTypes.ReserveConfigurationMap memory self, uint256 ltv) internal pure {
     require(ltv <= MAX_VALID_LTV, Errors.INVALID_LTV);
-
-    self.data = (self.data & LTV_MASK) | ltv;
+    self.intData.Ltv = ltv;
   }
 
   /**
@@ -82,7 +41,7 @@
    * @return The loan to value
    */
   function getLtv(DataTypes.ReserveConfigurationMap memory self) internal pure returns (uint256) {
-    return self.data & ~LTV_MASK;
+    return self.intData.Ltv;
   }
 
   /**
@@ -95,10 +54,7 @@
     uint256 threshold
   ) internal pure {
     require(threshold <= MAX_VALID_LIQUIDATION_THRESHOLD, Errors.INVALID_LIQ_THRESHOLD);
-
-    self.data =
-      (self.data & LIQUIDATION_THRESHOLD_MASK) |
-      (threshold << LIQUIDATION_THRESHOLD_START_BIT_POSITION);
+    self.intData.LiquidationThreshold = threshold;
   }
 
   /**
@@ -109,7 +65,7 @@
   function getLiquidationThreshold(
     DataTypes.ReserveConfigurationMap memory self
   ) internal pure returns (uint256) {
-    return (self.data & ~LIQUIDATION_THRESHOLD_MASK) >> LIQUIDATION_THRESHOLD_START_BIT_POSITION;
+    return self.intData.LiquidationThreshold;
   }
 
   /**
@@ -123,9 +79,7 @@
   ) internal pure {
     require(bonus <= MAX_VALID_LIQUIDATION_BONUS, Errors.INVALID_LIQ_BONUS);
 
-    self.data =
-      (self.data & LIQUIDATION_BONUS_MASK) |
-      (bonus << LIQUIDATION_BONUS_START_BIT_POSITION);
+    self.intData.LiquidationBonus = bonus;
   }
 
   /**
@@ -136,7 +90,7 @@
   function getLiquidationBonus(
     DataTypes.ReserveConfigurationMap memory self
   ) internal pure returns (uint256) {
-    return (self.data & ~LIQUIDATION_BONUS_MASK) >> LIQUIDATION_BONUS_START_BIT_POSITION;
+    return self.intData.LiquidationBonus;
   }
 
   /**
@@ -150,7 +104,7 @@
   ) internal pure {
     require(decimals <= MAX_VALID_DECIMALS, Errors.INVALID_DECIMALS);
 
-    self.data = (self.data & DECIMALS_MASK) | (decimals << RESERVE_DECIMALS_START_BIT_POSITION);
+    self.intData.Decimals = decimals;
   }
 
   /**
@@ -161,7 +115,7 @@
   function getDecimals(
     DataTypes.ReserveConfigurationMap memory self
   ) internal pure returns (uint256) {
-    return (self.data & ~DECIMALS_MASK) >> RESERVE_DECIMALS_START_BIT_POSITION;
+    return self.intData.Decimals;
   }
 
   /**
@@ -170,9 +124,7 @@
    * @param active The active state
    */
   function setActive(DataTypes.ReserveConfigurationMap memory self, bool active) internal pure {
-    self.data =
-      (self.data & ACTIVE_MASK) |
-      (uint256(active ? 1 : 0) << IS_ACTIVE_START_BIT_POSITION);
+    self.boolData.Active = active;
   }
 
   /**
@@ -182,7 +134,7 @@
    */
   function getActive(DataTypes.ReserveConfigurationMap memory self) external pure returns (bool) {
     // certora munge external
-    return (self.data & ~ACTIVE_MASK) != 0;
+    return self.boolData.Active;
   }
 
   /**
@@ -191,9 +143,7 @@
    * @param frozen The frozen state
    */
   function setFrozen(DataTypes.ReserveConfigurationMap memory self, bool frozen) internal pure {
-    self.data =
-      (self.data & FROZEN_MASK) |
-      (uint256(frozen ? 1 : 0) << IS_FROZEN_START_BIT_POSITION);
+    self.boolData.Frozen = frozen;
   }
 
   /**
@@ -203,7 +153,7 @@
    */
   function getFrozen(DataTypes.ReserveConfigurationMap memory self) external pure returns (bool) {
     // certora munge external
-    return (self.data & ~FROZEN_MASK) != 0;
+    return self.boolData.Frozen;
   }
 
   /**
@@ -212,9 +162,7 @@
    * @param paused The paused state
    */
   function setPaused(DataTypes.ReserveConfigurationMap memory self, bool paused) internal pure {
-    self.data =
-      (self.data & PAUSED_MASK) |
-      (uint256(paused ? 1 : 0) << IS_PAUSED_START_BIT_POSITION);
+    self.boolData.Paused = paused;
   }
 
   /**
@@ -223,7 +171,7 @@
    * @return The paused state
    */
   function getPaused(DataTypes.ReserveConfigurationMap memory self) internal pure returns (bool) {
-    return (self.data & ~PAUSED_MASK) != 0;
+    return self.boolData.Paused;
   }
 
   /**
@@ -239,9 +187,7 @@
     DataTypes.ReserveConfigurationMap memory self,
     bool borrowable
   ) internal pure {
-    self.data =
-      (self.data & BORROWABLE_IN_ISOLATION_MASK) |
-      (uint256(borrowable ? 1 : 0) << BORROWABLE_IN_ISOLATION_START_BIT_POSITION);
+    self.boolData.BorrowableInIsolation = borrowable;
   }
 
   /**
@@ -256,7 +202,7 @@
   function getBorrowableInIsolation(
     DataTypes.ReserveConfigurationMap memory self
   ) internal pure returns (bool) {
-    return (self.data & ~BORROWABLE_IN_ISOLATION_MASK) != 0;
+    return self.boolData.BorrowableInIsolation;
   }
 
   /**
@@ -269,9 +215,7 @@
     DataTypes.ReserveConfigurationMap memory self,
     bool siloed
   ) internal pure {
-    self.data =
-      (self.data & SILOED_BORROWING_MASK) |
-      (uint256(siloed ? 1 : 0) << SILOED_BORROWING_START_BIT_POSITION);
+    self.boolData.SiloedBorrowing = siloed;
   }
 
   /**
@@ -283,7 +227,7 @@
   function getSiloedBorrowing(
     DataTypes.ReserveConfigurationMap memory self
   ) internal pure returns (bool) {
-    return (self.data & ~SILOED_BORROWING_MASK) != 0;
+    return self.boolData.SiloedBorrowing;
   }
 
   /**
@@ -295,9 +239,7 @@
     DataTypes.ReserveConfigurationMap memory self,
     bool enabled
   ) internal pure {
-    self.data =
-      (self.data & BORROWING_MASK) |
-      (uint256(enabled ? 1 : 0) << BORROWING_ENABLED_START_BIT_POSITION);
+    self.boolData.BorrowingEnabled = enabled;
   }
 
   /**
@@ -309,7 +251,7 @@
     DataTypes.ReserveConfigurationMap memory self
   ) external pure returns (bool) {
     // certora munge external
-    return (self.data & ~BORROWING_MASK) != 0;
+    return self.boolData.BorrowingEnabled;
   }
 
   /**
@@ -321,9 +263,7 @@
     DataTypes.ReserveConfigurationMap memory self,
     bool enabled
   ) internal pure {
-    self.data =
-      (self.data & STABLE_BORROWING_MASK) |
-      (uint256(enabled ? 1 : 0) << STABLE_BORROWING_ENABLED_START_BIT_POSITION);
+    self.boolData.StableBorrowingEnabled = enabled;
   }
 
   /**
@@ -334,7 +274,7 @@
   function getStableRateBorrowingEnabled(
     DataTypes.ReserveConfigurationMap memory self
   ) internal pure returns (bool) {
-    return (self.data & ~STABLE_BORROWING_MASK) != 0;
+    return self.boolData.StableBorrowingEnabled;
   }
 
   /**
@@ -348,9 +288,7 @@
   ) internal pure {
     require(reserveFactor <= MAX_VALID_RESERVE_FACTOR, Errors.INVALID_RESERVE_FACTOR);
 
-    self.data =
-      (self.data & RESERVE_FACTOR_MASK) |
-      (reserveFactor << RESERVE_FACTOR_START_BIT_POSITION);
+    self.intData.ReserveFactor = reserveFactor;
   }
 
   /**
@@ -361,7 +299,7 @@
   function getReserveFactor(
     DataTypes.ReserveConfigurationMap memory self
   ) internal pure returns (uint256) {
-    return (self.data & ~RESERVE_FACTOR_MASK) >> RESERVE_FACTOR_START_BIT_POSITION;
+    return self.intData.ReserveFactor;
   }
 
   /**
@@ -375,7 +313,7 @@
   ) internal pure {
     require(borrowCap <= MAX_VALID_BORROW_CAP, Errors.INVALID_BORROW_CAP);
 
-    self.data = (self.data & BORROW_CAP_MASK) | (borrowCap << BORROW_CAP_START_BIT_POSITION);
+    self.intData.BorrowCap = borrowCap;
   }
 
   /**
@@ -386,7 +324,7 @@
   function getBorrowCap(
     DataTypes.ReserveConfigurationMap memory self
   ) internal pure returns (uint256) {
-    return (self.data & ~BORROW_CAP_MASK) >> BORROW_CAP_START_BIT_POSITION;
+    return self.intData.BorrowCap;
   }
 
   /**
@@ -400,7 +338,7 @@
   ) internal pure {
     require(supplyCap <= MAX_VALID_SUPPLY_CAP, Errors.INVALID_SUPPLY_CAP);
 
-    self.data = (self.data & SUPPLY_CAP_MASK) | (supplyCap << SUPPLY_CAP_START_BIT_POSITION);
+    self.intData.SupplyCap = supplyCap;
   }
 
   /**
@@ -411,7 +349,7 @@
   function getSupplyCap(
     DataTypes.ReserveConfigurationMap memory self
   ) internal pure returns (uint256) {
-    return (self.data & ~SUPPLY_CAP_MASK) >> SUPPLY_CAP_START_BIT_POSITION;
+    return self.intData.SupplyCap;
   }
 
   /**
@@ -425,7 +363,7 @@
   ) internal pure {
     require(ceiling <= MAX_VALID_DEBT_CEILING, Errors.INVALID_DEBT_CEILING);
 
-    self.data = (self.data & DEBT_CEILING_MASK) | (ceiling << DEBT_CEILING_START_BIT_POSITION);
+    self.intData.DebtCeiling = ceiling;
   }
 
   /**
@@ -436,7 +374,7 @@
   function getDebtCeiling(
     DataTypes.ReserveConfigurationMap memory self
   ) internal pure returns (uint256) {
-    return (self.data & ~DEBT_CEILING_MASK) >> DEBT_CEILING_START_BIT_POSITION;
+    return self.intData.DebtCeiling;
   }
 
   /**
@@ -453,9 +391,7 @@
       Errors.INVALID_LIQUIDATION_PROTOCOL_FEE
     );
 
-    self.data =
-      (self.data & LIQUIDATION_PROTOCOL_FEE_MASK) |
-      (liquidationProtocolFee << LIQUIDATION_PROTOCOL_FEE_START_BIT_POSITION);
+    self.intData.LiquidationProtocolFee = liquidationProtocolFee;
   }
 
   /**
@@ -466,8 +402,7 @@
   function getLiquidationProtocolFee(
     DataTypes.ReserveConfigurationMap memory self
   ) internal pure returns (uint256) {
-    return
-      (self.data & ~LIQUIDATION_PROTOCOL_FEE_MASK) >> LIQUIDATION_PROTOCOL_FEE_START_BIT_POSITION;
+    return self.intData.LiquidationProtocolFee;
   }
 
   /**
@@ -481,9 +416,7 @@
   ) internal pure {
     require(unbackedMintCap <= MAX_VALID_UNBACKED_MINT_CAP, Errors.INVALID_UNBACKED_MINT_CAP);
 
-    self.data =
-      (self.data & UNBACKED_MINT_CAP_MASK) |
-      (unbackedMintCap << UNBACKED_MINT_CAP_START_BIT_POSITION);
+    self.intData.UnbackedMintCap = unbackedMintCap;
   }
 
   /**
@@ -494,7 +427,7 @@
   function getUnbackedMintCap(
     DataTypes.ReserveConfigurationMap memory self
   ) internal pure returns (uint256) {
-    return (self.data & ~UNBACKED_MINT_CAP_MASK) >> UNBACKED_MINT_CAP_START_BIT_POSITION;
+    return self.intData.UnbackedMintCap;
   }
 
   /**
@@ -508,7 +441,7 @@
   ) internal pure {
     require(category <= MAX_VALID_EMODE_CATEGORY, Errors.INVALID_EMODE_CATEGORY);
 
-    self.data = (self.data & EMODE_CATEGORY_MASK) | (category << EMODE_CATEGORY_START_BIT_POSITION);
+    self.intData.EModeCategory = category;
   }
 
   /**
@@ -519,7 +452,7 @@
   function getEModeCategory(
     DataTypes.ReserveConfigurationMap memory self
   ) internal pure returns (uint256) {
-    return (self.data & ~EMODE_CATEGORY_MASK) >> EMODE_CATEGORY_START_BIT_POSITION;
+    return self.intData.EModeCategory;
   }
 
   /**
@@ -531,9 +464,7 @@
     DataTypes.ReserveConfigurationMap memory self,
     bool flashLoanEnabled
   ) internal pure {
-    self.data =
-      (self.data & FLASHLOAN_ENABLED_MASK) |
-      (uint256(flashLoanEnabled ? 1 : 0) << FLASHLOAN_ENABLED_START_BIT_POSITION);
+    self.boolData.FlashLoanEnabled = flashLoanEnabled;
   }
 
   /**
@@ -544,7 +475,7 @@
   function getFlashLoanEnabled(
     DataTypes.ReserveConfigurationMap memory self
   ) internal pure returns (bool) {
-    return (self.data & ~FLASHLOAN_ENABLED_MASK) != 0;
+    return self.boolData.FlashLoanEnabled;
   }
 
   /**
@@ -559,14 +490,12 @@
   function getFlags(
     DataTypes.ReserveConfigurationMap memory self
   ) internal pure returns (bool, bool, bool, bool, bool) {
-    uint256 dataLocal = self.data;
-
     return (
-      (dataLocal & ~ACTIVE_MASK) != 0,
-      (dataLocal & ~FROZEN_MASK) != 0,
-      (dataLocal & ~BORROWING_MASK) != 0,
-      (dataLocal & ~STABLE_BORROWING_MASK) != 0,
-      (dataLocal & ~PAUSED_MASK) != 0
+      self.boolData.Active,
+      self.boolData.Frozen,
+      self.boolData.BorrowingEnabled,
+      self.boolData.StableBorrowingEnabled,
+      self.boolData.Paused
     );
   }
 
@@ -583,15 +512,13 @@
   function getParams(
     DataTypes.ReserveConfigurationMap memory self
   ) internal pure returns (uint256, uint256, uint256, uint256, uint256, uint256) {
-    uint256 dataLocal = self.data;
-
     return (
-      dataLocal & ~LTV_MASK,
-      (dataLocal & ~LIQUIDATION_THRESHOLD_MASK) >> LIQUIDATION_THRESHOLD_START_BIT_POSITION,
-      (dataLocal & ~LIQUIDATION_BONUS_MASK) >> LIQUIDATION_BONUS_START_BIT_POSITION,
-      (dataLocal & ~DECIMALS_MASK) >> RESERVE_DECIMALS_START_BIT_POSITION,
-      (dataLocal & ~RESERVE_FACTOR_MASK) >> RESERVE_FACTOR_START_BIT_POSITION,
-      (dataLocal & ~EMODE_CATEGORY_MASK) >> EMODE_CATEGORY_START_BIT_POSITION
+      self.intData.Ltv,
+      self.intData.LiquidationThreshold,
+      self.intData.LiquidationBonus,
+      self.intData.Decimals,
+      self.intData.ReserveFactor,
+      self.intData.EModeCategory
     );
   }
 
@@ -604,11 +531,9 @@
   function getCaps(
     DataTypes.ReserveConfigurationMap memory self
   ) internal pure returns (uint256, uint256) {
-    uint256 dataLocal = self.data;
-
     return (
-      (dataLocal & ~BORROW_CAP_MASK) >> BORROW_CAP_START_BIT_POSITION,
-      (dataLocal & ~SUPPLY_CAP_MASK) >> SUPPLY_CAP_START_BIT_POSITION
+      self.intData.BorrowCap,
+      self.intData.SupplyCap
     );
   }
 }
diff -ruN protocol/libraries/configuration/ReserveConfiguration_noBV.sol protocol/libraries/configuration/ReserveConfiguration_noBV.sol
--- protocol/libraries/configuration/ReserveConfiguration_noBV.sol	1970-01-01 01:00:00
+++ protocol/libraries/configuration/ReserveConfiguration_noBV.sol	2023-11-20 09:12:19
@@ -0,0 +1,539 @@
+// SPDX-License-Identifier: BUSL-1.1
+pragma solidity ^0.8.0;
+
+import {Errors} from '../helpers/Errors.sol';
+import {DataTypes} from '../types/DataTypes.sol';
+
+/**
+ * @title ReserveConfiguration library
+ * @author Aave
+ * @notice Implements the bitmap logic to handle the reserve configuration
+ */
+library ReserveConfiguration {
+  uint256 internal constant MAX_VALID_LTV = 65535;
+  uint256 internal constant MAX_VALID_LIQUIDATION_THRESHOLD = 65535;
+  uint256 internal constant MAX_VALID_LIQUIDATION_BONUS = 65535;
+  uint256 internal constant MAX_VALID_DECIMALS = 255;
+  uint256 internal constant MAX_VALID_RESERVE_FACTOR = 65535;
+  uint256 internal constant MAX_VALID_BORROW_CAP = 68719476735;
+  uint256 internal constant MAX_VALID_SUPPLY_CAP = 68719476735;
+  uint256 internal constant MAX_VALID_LIQUIDATION_PROTOCOL_FEE = 65535;
+  uint256 internal constant MAX_VALID_EMODE_CATEGORY = 255;
+  uint256 internal constant MAX_VALID_UNBACKED_MINT_CAP = 68719476735;
+  uint256 internal constant MAX_VALID_DEBT_CEILING = 1099511627775;
+
+  uint256 public constant DEBT_CEILING_DECIMALS = 2;
+  uint16 public constant MAX_RESERVES_COUNT = 3;
+
+  /**
+   * @notice Sets the Loan to Value of the reserve
+   * @param self The reserve configuration
+   * @param ltv The new ltv
+   */
+  function setLtv(DataTypes.ReserveConfigurationMap memory self, uint256 ltv) internal pure {
+    require(ltv <= MAX_VALID_LTV, Errors.INVALID_LTV);
+    self.intData.Ltv = ltv;
+  }
+
+  /**
+   * @notice Gets the Loan to Value of the reserve
+   * @param self The reserve configuration
+   * @return The loan to value
+   */
+  function getLtv(DataTypes.ReserveConfigurationMap memory self) internal pure returns (uint256) {
+    return self.intData.Ltv;
+  }
+
+  /**
+   * @notice Sets the liquidation threshold of the reserve
+   * @param self The reserve configuration
+   * @param threshold The new liquidation threshold
+   */
+  function setLiquidationThreshold(
+    DataTypes.ReserveConfigurationMap memory self,
+    uint256 threshold
+  ) internal pure {
+    require(threshold <= MAX_VALID_LIQUIDATION_THRESHOLD, Errors.INVALID_LIQ_THRESHOLD);
+    self.intData.LiquidationThreshold = threshold;
+  }
+
+  /**
+   * @notice Gets the liquidation threshold of the reserve
+   * @param self The reserve configuration
+   * @return The liquidation threshold
+   */
+  function getLiquidationThreshold(
+    DataTypes.ReserveConfigurationMap memory self
+  ) internal pure returns (uint256) {
+    return self.intData.LiquidationThreshold;
+  }
+
+  /**
+   * @notice Sets the liquidation bonus of the reserve
+   * @param self The reserve configuration
+   * @param bonus The new liquidation bonus
+   */
+  function setLiquidationBonus(
+    DataTypes.ReserveConfigurationMap memory self,
+    uint256 bonus
+  ) internal pure {
+    require(bonus <= MAX_VALID_LIQUIDATION_BONUS, Errors.INVALID_LIQ_BONUS);
+
+    self.intData.LiquidationBonus = bonus;
+  }
+
+  /**
+   * @notice Gets the liquidation bonus of the reserve
+   * @param self The reserve configuration
+   * @return The liquidation bonus
+   */
+  function getLiquidationBonus(
+    DataTypes.ReserveConfigurationMap memory self
+  ) internal pure returns (uint256) {
+    return self.intData.LiquidationBonus;
+  }
+
+  /**
+   * @notice Sets the decimals of the underlying asset of the reserve
+   * @param self The reserve configuration
+   * @param decimals The decimals
+   */
+  function setDecimals(
+    DataTypes.ReserveConfigurationMap memory self,
+    uint256 decimals
+  ) internal pure {
+    require(decimals <= MAX_VALID_DECIMALS, Errors.INVALID_DECIMALS);
+
+    self.intData.Decimals = decimals;
+  }
+
+  /**
+   * @notice Gets the decimals of the underlying asset of the reserve
+   * @param self The reserve configuration
+   * @return The decimals of the asset
+   */
+  function getDecimals(
+    DataTypes.ReserveConfigurationMap memory self
+  ) internal pure returns (uint256) {
+    return self.intData.Decimals;
+  }
+
+  /**
+   * @notice Sets the active state of the reserve
+   * @param self The reserve configuration
+   * @param active The active state
+   */
+  function setActive(DataTypes.ReserveConfigurationMap memory self, bool active) internal pure {
+    self.boolData.Active = active;
+  }
+
+  /**
+   * @notice Gets the active state of the reserve
+   * @param self The reserve configuration
+   * @return The active state
+   */
+  function getActive(DataTypes.ReserveConfigurationMap memory self) external pure returns (bool) {
+    // certora munge external
+    return self.boolData.Active;
+  }
+
+  /**
+   * @notice Sets the frozen state of the reserve
+   * @param self The reserve configuration
+   * @param frozen The frozen state
+   */
+  function setFrozen(DataTypes.ReserveConfigurationMap memory self, bool frozen) internal pure {
+    self.boolData.Frozen = frozen;
+  }
+
+  /**
+   * @notice Gets the frozen state of the reserve
+   * @param self The reserve configuration
+   * @return The frozen state
+   */
+  function getFrozen(DataTypes.ReserveConfigurationMap memory self) external pure returns (bool) {
+    // certora munge external
+    return self.boolData.Frozen;
+  }
+
+  /**
+   * @notice Sets the paused state of the reserve
+   * @param self The reserve configuration
+   * @param paused The paused state
+   */
+  function setPaused(DataTypes.ReserveConfigurationMap memory self, bool paused) internal pure {
+    self.boolData.Paused = paused;
+  }
+
+  /**
+   * @notice Gets the paused state of the reserve
+   * @param self The reserve configuration
+   * @return The paused state
+   */
+  function getPaused(DataTypes.ReserveConfigurationMap memory self) internal pure returns (bool) {
+    return self.boolData.Paused;
+  }
+
+  /**
+   * @notice Sets the borrowable in isolation flag for the reserve.
+   * @dev When this flag is set to true, the asset will be borrowable against isolated collaterals and the borrowed
+   * amount will be accumulated in the isolated collateral's total debt exposure.
+   * @dev Only assets of the same family (eg USD stablecoins) should be borrowable in isolation mode to keep
+   * consistency in the debt ceiling calculations.
+   * @param self The reserve configuration
+   * @param borrowable True if the asset is borrowable
+   */
+  function setBorrowableInIsolation(
+    DataTypes.ReserveConfigurationMap memory self,
+    bool borrowable
+  ) internal pure {
+    self.boolData.BorrowableInIsolation = borrowable;
+  }
+
+  /**
+   * @notice Gets the borrowable in isolation flag for the reserve.
+   * @dev If the returned flag is true, the asset is borrowable against isolated collateral. Assets borrowed with
+   * isolated collateral is accounted for in the isolated collateral's total debt exposure.
+   * @dev Only assets of the same family (eg USD stablecoins) should be borrowable in isolation mode to keep
+   * consistency in the debt ceiling calculations.
+   * @param self The reserve configuration
+   * @return The borrowable in isolation flag
+   */
+  function getBorrowableInIsolation(
+    DataTypes.ReserveConfigurationMap memory self
+  ) internal pure returns (bool) {
+    return self.boolData.BorrowableInIsolation;
+  }
+
+  /**
+   * @notice Sets the siloed borrowing flag for the reserve.
+   * @dev When this flag is set to true, users borrowing this asset will not be allowed to borrow any other asset.
+   * @param self The reserve configuration
+   * @param siloed True if the asset is siloed
+   */
+  function setSiloedBorrowing(
+    DataTypes.ReserveConfigurationMap memory self,
+    bool siloed
+  ) internal pure {
+    self.boolData.SiloedBorrowing = siloed;
+  }
+
+  /**
+   * @notice Gets the siloed borrowing flag for the reserve.
+   * @dev When this flag is set to true, users borrowing this asset will not be allowed to borrow any other asset.
+   * @param self The reserve configuration
+   * @return The siloed borrowing flag
+   */
+  function getSiloedBorrowing(
+    DataTypes.ReserveConfigurationMap memory self
+  ) internal pure returns (bool) {
+    return self.boolData.SiloedBorrowing;
+  }
+
+  /**
+   * @notice Enables or disables borrowing on the reserve
+   * @param self The reserve configuration
+   * @param enabled True if the borrowing needs to be enabled, false otherwise
+   */
+  function setBorrowingEnabled(
+    DataTypes.ReserveConfigurationMap memory self,
+    bool enabled
+  ) internal pure {
+    self.boolData.BorrowingEnabled = enabled;
+  }
+
+  /**
+   * @notice Gets the borrowing state of the reserve
+   * @param self The reserve configuration
+   * @return The borrowing state
+   */
+  function getBorrowingEnabled(
+    DataTypes.ReserveConfigurationMap memory self
+  ) external pure returns (bool) {
+    // certora munge external
+    return self.boolData.BorrowingEnabled;
+  }
+
+  /**
+   * @notice Enables or disables stable rate borrowing on the reserve
+   * @param self The reserve configuration
+   * @param enabled True if the stable rate borrowing needs to be enabled, false otherwise
+   */
+  function setStableRateBorrowingEnabled(
+    DataTypes.ReserveConfigurationMap memory self,
+    bool enabled
+  ) internal pure {
+    self.boolData.StableBorrowingEnabled = enabled;
+  }
+
+  /**
+   * @notice Gets the stable rate borrowing state of the reserve
+   * @param self The reserve configuration
+   * @return The stable rate borrowing state
+   */
+  function getStableRateBorrowingEnabled(
+    DataTypes.ReserveConfigurationMap memory self
+  ) internal pure returns (bool) {
+    return self.boolData.StableBorrowingEnabled;
+  }
+
+  /**
+   * @notice Sets the reserve factor of the reserve
+   * @param self The reserve configuration
+   * @param reserveFactor The reserve factor
+   */
+  function setReserveFactor(
+    DataTypes.ReserveConfigurationMap memory self,
+    uint256 reserveFactor
+  ) internal pure {
+    require(reserveFactor <= MAX_VALID_RESERVE_FACTOR, Errors.INVALID_RESERVE_FACTOR);
+
+    self.intData.ReserveFactor = reserveFactor;
+  }
+
+  /**
+   * @notice Gets the reserve factor of the reserve
+   * @param self The reserve configuration
+   * @return The reserve factor
+   */
+  function getReserveFactor(
+    DataTypes.ReserveConfigurationMap memory self
+  ) internal pure returns (uint256) {
+    return self.intData.ReserveFactor;
+  }
+
+  /**
+   * @notice Sets the borrow cap of the reserve
+   * @param self The reserve configuration
+   * @param borrowCap The borrow cap
+   */
+  function setBorrowCap(
+    DataTypes.ReserveConfigurationMap memory self,
+    uint256 borrowCap
+  ) internal pure {
+    require(borrowCap <= MAX_VALID_BORROW_CAP, Errors.INVALID_BORROW_CAP);
+
+    self.intData.BorrowCap = borrowCap;
+  }
+
+  /**
+   * @notice Gets the borrow cap of the reserve
+   * @param self The reserve configuration
+   * @return The borrow cap
+   */
+  function getBorrowCap(
+    DataTypes.ReserveConfigurationMap memory self
+  ) internal pure returns (uint256) {
+    return self.intData.BorrowCap;
+  }
+
+  /**
+   * @notice Sets the supply cap of the reserve
+   * @param self The reserve configuration
+   * @param supplyCap The supply cap
+   */
+  function setSupplyCap(
+    DataTypes.ReserveConfigurationMap memory self,
+    uint256 supplyCap
+  ) internal pure {
+    require(supplyCap <= MAX_VALID_SUPPLY_CAP, Errors.INVALID_SUPPLY_CAP);
+
+    self.intData.SupplyCap = supplyCap;
+  }
+
+  /**
+   * @notice Gets the supply cap of the reserve
+   * @param self The reserve configuration
+   * @return The supply cap
+   */
+  function getSupplyCap(
+    DataTypes.ReserveConfigurationMap memory self
+  ) internal pure returns (uint256) {
+    return self.intData.SupplyCap;
+  }
+
+  /**
+   * @notice Sets the debt ceiling in isolation mode for the asset
+   * @param self The reserve configuration
+   * @param ceiling The maximum debt ceiling for the asset
+   */
+  function setDebtCeiling(
+    DataTypes.ReserveConfigurationMap memory self,
+    uint256 ceiling
+  ) internal pure {
+    require(ceiling <= MAX_VALID_DEBT_CEILING, Errors.INVALID_DEBT_CEILING);
+
+    self.intData.DebtCeiling = ceiling;
+  }
+
+  /**
+   * @notice Gets the debt ceiling for the asset if the asset is in isolation mode
+   * @param self The reserve configuration
+   * @return The debt ceiling (0 = isolation mode disabled)
+   */
+  function getDebtCeiling(
+    DataTypes.ReserveConfigurationMap memory self
+  ) internal pure returns (uint256) {
+    return self.intData.DebtCeiling;
+  }
+
+  /**
+   * @notice Sets the liquidation protocol fee of the reserve
+   * @param self The reserve configuration
+   * @param liquidationProtocolFee The liquidation protocol fee
+   */
+  function setLiquidationProtocolFee(
+    DataTypes.ReserveConfigurationMap memory self,
+    uint256 liquidationProtocolFee
+  ) internal pure {
+    require(
+      liquidationProtocolFee <= MAX_VALID_LIQUIDATION_PROTOCOL_FEE,
+      Errors.INVALID_LIQUIDATION_PROTOCOL_FEE
+    );
+
+    self.intData.LiquidationProtocolFee = liquidationProtocolFee;
+  }
+
+  /**
+   * @dev Gets the liquidation protocol fee
+   * @param self The reserve configuration
+   * @return The liquidation protocol fee
+   */
+  function getLiquidationProtocolFee(
+    DataTypes.ReserveConfigurationMap memory self
+  ) internal pure returns (uint256) {
+    return self.intData.LiquidationProtocolFee;
+  }
+
+  /**
+   * @notice Sets the unbacked mint cap of the reserve
+   * @param self The reserve configuration
+   * @param unbackedMintCap The unbacked mint cap
+   */
+  function setUnbackedMintCap(
+    DataTypes.ReserveConfigurationMap memory self,
+    uint256 unbackedMintCap
+  ) internal pure {
+    require(unbackedMintCap <= MAX_VALID_UNBACKED_MINT_CAP, Errors.INVALID_UNBACKED_MINT_CAP);
+
+    self.intData.UnbackedMintCap = unbackedMintCap;
+  }
+
+  /**
+   * @dev Gets the unbacked mint cap of the reserve
+   * @param self The reserve configuration
+   * @return The unbacked mint cap
+   */
+  function getUnbackedMintCap(
+    DataTypes.ReserveConfigurationMap memory self
+  ) internal pure returns (uint256) {
+    return self.intData.UnbackedMintCap;
+  }
+
+  /**
+   * @notice Sets the eMode asset category
+   * @param self The reserve configuration
+   * @param category The asset category when the user selects the eMode
+   */
+  function setEModeCategory(
+    DataTypes.ReserveConfigurationMap memory self,
+    uint256 category
+  ) internal pure {
+    require(category <= MAX_VALID_EMODE_CATEGORY, Errors.INVALID_EMODE_CATEGORY);
+
+    self.intData.EModeCategory = category;
+  }
+
+  /**
+   * @dev Gets the eMode asset category
+   * @param self The reserve configuration
+   * @return The eMode category for the asset
+   */
+  function getEModeCategory(
+    DataTypes.ReserveConfigurationMap memory self
+  ) internal pure returns (uint256) {
+    return self.intData.EModeCategory;
+  }
+
+  /**
+   * @notice Sets the flashloanable flag for the reserve
+   * @param self The reserve configuration
+   * @param flashLoanEnabled True if the asset is flashloanable, false otherwise
+   */
+  function setFlashLoanEnabled(
+    DataTypes.ReserveConfigurationMap memory self,
+    bool flashLoanEnabled
+  ) internal pure {
+    self.boolData.FlashLoanEnabled = flashLoanEnabled;
+  }
+
+  /**
+   * @notice Gets the flashloanable flag for the reserve
+   * @param self The reserve configuration
+   * @return The flashloanable flag
+   */
+  function getFlashLoanEnabled(
+    DataTypes.ReserveConfigurationMap memory self
+  ) internal pure returns (bool) {
+    return self.boolData.FlashLoanEnabled;
+  }
+
+  /**
+   * @notice Gets the configuration flags of the reserve
+   * @param self The reserve configuration
+   * @return The state flag representing active
+   * @return The state flag representing frozen
+   * @return The state flag representing borrowing enabled
+   * @return The state flag representing stableRateBorrowing enabled
+   * @return The state flag representing paused
+   */
+  function getFlags(
+    DataTypes.ReserveConfigurationMap memory self
+  ) internal pure returns (bool, bool, bool, bool, bool) {
+    return (
+      self.boolData.Active,
+      self.boolData.Frozen,
+      self.boolData.BorrowingEnabled,
+      self.boolData.StableBorrowingEnabled,
+      self.boolData.Paused
+    );
+  }
+
+  /**
+   * @notice Gets the configuration parameters of the reserve from storage
+   * @param self The reserve configuration
+   * @return The state param representing ltv
+   * @return The state param representing liquidation threshold
+   * @return The state param representing liquidation bonus
+   * @return The state param representing reserve decimals
+   * @return The state param representing reserve factor
+   * @return The state param representing eMode category
+   */
+  function getParams(
+    DataTypes.ReserveConfigurationMap memory self
+  ) internal pure returns (uint256, uint256, uint256, uint256, uint256, uint256) {
+    return (
+      self.intData.Ltv,
+      self.intData.LiquidationThreshold,
+      self.intData.LiquidationBonus,
+      self.intData.Decimals,
+      self.intData.ReserveFactor,
+      self.intData.EModeCategory
+    );
+  }
+
+  /**
+   * @notice Gets the caps parameters of the reserve from storage
+   * @param self The reserve configuration
+   * @return The state param representing borrow cap
+   * @return The state param representing supply cap.
+   */
+  function getCaps(
+    DataTypes.ReserveConfigurationMap memory self
+  ) internal pure returns (uint256, uint256) {
+    return (
+      self.intData.BorrowCap,
+      self.intData.SupplyCap
+    );
+  }
+}
diff -ruN protocol/libraries/configuration/ReserveConfiguration_orig.sol protocol/libraries/configuration/ReserveConfiguration_orig.sol
--- protocol/libraries/configuration/ReserveConfiguration_orig.sol	1970-01-01 01:00:00
+++ protocol/libraries/configuration/ReserveConfiguration_orig.sol	2023-11-20 09:12:19
@@ -0,0 +1,614 @@
+// SPDX-License-Identifier: BUSL-1.1
+pragma solidity ^0.8.0;
+
+import {Errors} from '../helpers/Errors.sol';
+import {DataTypes} from '../types/DataTypes.sol';
+
+/**
+ * @title ReserveConfiguration library
+ * @author Aave
+ * @notice Implements the bitmap logic to handle the reserve configuration
+ */
+library ReserveConfiguration {
+  uint256 internal constant LTV_MASK =                       0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000; // prettier-ignore
+  uint256 internal constant LIQUIDATION_THRESHOLD_MASK =     0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFF; // prettier-ignore
+  uint256 internal constant LIQUIDATION_BONUS_MASK =         0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFF; // prettier-ignore
+  uint256 internal constant DECIMALS_MASK =                  0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00FFFFFFFFFFFF; // prettier-ignore
+  uint256 internal constant ACTIVE_MASK =                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFF; // prettier-ignore
+  uint256 internal constant FROZEN_MASK =                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFFFFFFFFFFFFFF; // prettier-ignore
+  uint256 internal constant BORROWING_MASK =                 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFBFFFFFFFFFFFFFF; // prettier-ignore
+  uint256 internal constant STABLE_BORROWING_MASK =          0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFFFFF; // prettier-ignore
+  uint256 internal constant PAUSED_MASK =                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFF; // prettier-ignore
+  uint256 internal constant BORROWABLE_IN_ISOLATION_MASK =   0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFFFFFFFFFFFFFFF; // prettier-ignore
+  uint256 internal constant SILOED_BORROWING_MASK =          0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFBFFFFFFFFFFFFFFF; // prettier-ignore
+  uint256 internal constant FLASHLOAN_ENABLED_MASK =         0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFFFFFF; // prettier-ignore
+  uint256 internal constant RESERVE_FACTOR_MASK =            0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFFFFFFFFFF; // prettier-ignore
+  uint256 internal constant BORROW_CAP_MASK =                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000FFFFFFFFFFFFFFFFFFFF; // prettier-ignore
+  uint256 internal constant SUPPLY_CAP_MASK =                0xFFFFFFFFFFFFFFFFFFFFFFFFFF000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore
+  uint256 internal constant LIQUIDATION_PROTOCOL_FEE_MASK =  0xFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore
+  uint256 internal constant EMODE_CATEGORY_MASK =            0xFFFFFFFFFFFFFFFFFFFF00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore
+  uint256 internal constant UNBACKED_MINT_CAP_MASK =         0xFFFFFFFFFFF000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore
+  uint256 internal constant DEBT_CEILING_MASK =              0xF0000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore
+
+  /// @dev For the LTV, the start bit is 0 (up to 15), hence no bitshifting is needed
+  uint256 internal constant LIQUIDATION_THRESHOLD_START_BIT_POSITION = 16;
+  uint256 internal constant LIQUIDATION_BONUS_START_BIT_POSITION = 32;
+  uint256 internal constant RESERVE_DECIMALS_START_BIT_POSITION = 48;
+  uint256 internal constant IS_ACTIVE_START_BIT_POSITION = 56;
+  uint256 internal constant IS_FROZEN_START_BIT_POSITION = 57;
+  uint256 internal constant BORROWING_ENABLED_START_BIT_POSITION = 58;
+  uint256 internal constant STABLE_BORROWING_ENABLED_START_BIT_POSITION = 59;
+  uint256 internal constant IS_PAUSED_START_BIT_POSITION = 60;
+  uint256 internal constant BORROWABLE_IN_ISOLATION_START_BIT_POSITION = 61;
+  uint256 internal constant SILOED_BORROWING_START_BIT_POSITION = 62;
+  uint256 internal constant FLASHLOAN_ENABLED_START_BIT_POSITION = 63;
+  uint256 internal constant RESERVE_FACTOR_START_BIT_POSITION = 64;
+  uint256 internal constant BORROW_CAP_START_BIT_POSITION = 80;
+  uint256 internal constant SUPPLY_CAP_START_BIT_POSITION = 116;
+  uint256 internal constant LIQUIDATION_PROTOCOL_FEE_START_BIT_POSITION = 152;
+  uint256 internal constant EMODE_CATEGORY_START_BIT_POSITION = 168;
+  uint256 internal constant UNBACKED_MINT_CAP_START_BIT_POSITION = 176;
+  uint256 internal constant DEBT_CEILING_START_BIT_POSITION = 212;
+
+  uint256 internal constant MAX_VALID_LTV = 65535;
+  uint256 internal constant MAX_VALID_LIQUIDATION_THRESHOLD = 65535;
+  uint256 internal constant MAX_VALID_LIQUIDATION_BONUS = 65535;
+  uint256 internal constant MAX_VALID_DECIMALS = 255;
+  uint256 internal constant MAX_VALID_RESERVE_FACTOR = 65535;
+  uint256 internal constant MAX_VALID_BORROW_CAP = 68719476735;
+  uint256 internal constant MAX_VALID_SUPPLY_CAP = 68719476735;
+  uint256 internal constant MAX_VALID_LIQUIDATION_PROTOCOL_FEE = 65535;
+  uint256 internal constant MAX_VALID_EMODE_CATEGORY = 255;
+  uint256 internal constant MAX_VALID_UNBACKED_MINT_CAP = 68719476735;
+  uint256 internal constant MAX_VALID_DEBT_CEILING = 1099511627775;
+
+  uint256 public constant DEBT_CEILING_DECIMALS = 2;
+  uint16 public constant MAX_RESERVES_COUNT = 3;
+
+  /**
+   * @notice Sets the Loan to Value of the reserve
+   * @param self The reserve configuration
+   * @param ltv The new ltv
+   */
+  function setLtv(DataTypes.ReserveConfigurationMap memory self, uint256 ltv) internal pure {
+    require(ltv <= MAX_VALID_LTV, Errors.INVALID_LTV);
+
+    self.data = (self.data & LTV_MASK) | ltv;
+  }
+
+  /**
+   * @notice Gets the Loan to Value of the reserve
+   * @param self The reserve configuration
+   * @return The loan to value
+   */
+  function getLtv(DataTypes.ReserveConfigurationMap memory self) internal pure returns (uint256) {
+    return self.data & ~LTV_MASK;
+  }
+
+  /**
+   * @notice Sets the liquidation threshold of the reserve
+   * @param self The reserve configuration
+   * @param threshold The new liquidation threshold
+   */
+  function setLiquidationThreshold(
+    DataTypes.ReserveConfigurationMap memory self,
+    uint256 threshold
+  ) internal pure {
+    require(threshold <= MAX_VALID_LIQUIDATION_THRESHOLD, Errors.INVALID_LIQ_THRESHOLD);
+
+    self.data =
+      (self.data & LIQUIDATION_THRESHOLD_MASK) |
+      (threshold << LIQUIDATION_THRESHOLD_START_BIT_POSITION);
+  }
+
+  /**
+   * @notice Gets the liquidation threshold of the reserve
+   * @param self The reserve configuration
+   * @return The liquidation threshold
+   */
+  function getLiquidationThreshold(
+    DataTypes.ReserveConfigurationMap memory self
+  ) internal pure returns (uint256) {
+    return (self.data & ~LIQUIDATION_THRESHOLD_MASK) >> LIQUIDATION_THRESHOLD_START_BIT_POSITION;
+  }
+
+  /**
+   * @notice Sets the liquidation bonus of the reserve
+   * @param self The reserve configuration
+   * @param bonus The new liquidation bonus
+   */
+  function setLiquidationBonus(
+    DataTypes.ReserveConfigurationMap memory self,
+    uint256 bonus
+  ) internal pure {
+    require(bonus <= MAX_VALID_LIQUIDATION_BONUS, Errors.INVALID_LIQ_BONUS);
+
+    self.data =
+      (self.data & LIQUIDATION_BONUS_MASK) |
+      (bonus << LIQUIDATION_BONUS_START_BIT_POSITION);
+  }
+
+  /**
+   * @notice Gets the liquidation bonus of the reserve
+   * @param self The reserve configuration
+   * @return The liquidation bonus
+   */
+  function getLiquidationBonus(
+    DataTypes.ReserveConfigurationMap memory self
+  ) internal pure returns (uint256) {
+    return (self.data & ~LIQUIDATION_BONUS_MASK) >> LIQUIDATION_BONUS_START_BIT_POSITION;
+  }
+
+  /**
+   * @notice Sets the decimals of the underlying asset of the reserve
+   * @param self The reserve configuration
+   * @param decimals The decimals
+   */
+  function setDecimals(
+    DataTypes.ReserveConfigurationMap memory self,
+    uint256 decimals
+  ) internal pure {
+    require(decimals <= MAX_VALID_DECIMALS, Errors.INVALID_DECIMALS);
+
+    self.data = (self.data & DECIMALS_MASK) | (decimals << RESERVE_DECIMALS_START_BIT_POSITION);
+  }
+
+  /**
+   * @notice Gets the decimals of the underlying asset of the reserve
+   * @param self The reserve configuration
+   * @return The decimals of the asset
+   */
+  function getDecimals(
+    DataTypes.ReserveConfigurationMap memory self
+  ) internal pure returns (uint256) {
+    return (self.data & ~DECIMALS_MASK) >> RESERVE_DECIMALS_START_BIT_POSITION;
+  }
+
+  /**
+   * @notice Sets the active state of the reserve
+   * @param self The reserve configuration
+   * @param active The active state
+   */
+  function setActive(DataTypes.ReserveConfigurationMap memory self, bool active) internal pure {
+    self.data =
+      (self.data & ACTIVE_MASK) |
+      (uint256(active ? 1 : 0) << IS_ACTIVE_START_BIT_POSITION);
+  }
+
+  /**
+   * @notice Gets the active state of the reserve
+   * @param self The reserve configuration
+   * @return The active state
+   */
+  function getActive(DataTypes.ReserveConfigurationMap memory self) external pure returns (bool) {
+    // certora munge external
+    return (self.data & ~ACTIVE_MASK) != 0;
+  }
+
+  /**
+   * @notice Sets the frozen state of the reserve
+   * @param self The reserve configuration
+   * @param frozen The frozen state
+   */
+  function setFrozen(DataTypes.ReserveConfigurationMap memory self, bool frozen) internal pure {
+    self.data =
+      (self.data & FROZEN_MASK) |
+      (uint256(frozen ? 1 : 0) << IS_FROZEN_START_BIT_POSITION);
+  }
+
+  /**
+   * @notice Gets the frozen state of the reserve
+   * @param self The reserve configuration
+   * @return The frozen state
+   */
+  function getFrozen(DataTypes.ReserveConfigurationMap memory self) external pure returns (bool) {
+    // certora munge external
+    return (self.data & ~FROZEN_MASK) != 0;
+  }
+
+  /**
+   * @notice Sets the paused state of the reserve
+   * @param self The reserve configuration
+   * @param paused The paused state
+   */
+  function setPaused(DataTypes.ReserveConfigurationMap memory self, bool paused) internal pure {
+    self.data =
+      (self.data & PAUSED_MASK) |
+      (uint256(paused ? 1 : 0) << IS_PAUSED_START_BIT_POSITION);
+  }
+
+  /**
+   * @notice Gets the paused state of the reserve
+   * @param self The reserve configuration
+   * @return The paused state
+   */
+  function getPaused(DataTypes.ReserveConfigurationMap memory self) internal pure returns (bool) {
+    return (self.data & ~PAUSED_MASK) != 0;
+  }
+
+  /**
+   * @notice Sets the borrowable in isolation flag for the reserve.
+   * @dev When this flag is set to true, the asset will be borrowable against isolated collaterals and the borrowed
+   * amount will be accumulated in the isolated collateral's total debt exposure.
+   * @dev Only assets of the same family (eg USD stablecoins) should be borrowable in isolation mode to keep
+   * consistency in the debt ceiling calculations.
+   * @param self The reserve configuration
+   * @param borrowable True if the asset is borrowable
+   */
+  function setBorrowableInIsolation(
+    DataTypes.ReserveConfigurationMap memory self,
+    bool borrowable
+  ) internal pure {
+    self.data =
+      (self.data & BORROWABLE_IN_ISOLATION_MASK) |
+      (uint256(borrowable ? 1 : 0) << BORROWABLE_IN_ISOLATION_START_BIT_POSITION);
+  }
+
+  /**
+   * @notice Gets the borrowable in isolation flag for the reserve.
+   * @dev If the returned flag is true, the asset is borrowable against isolated collateral. Assets borrowed with
+   * isolated collateral is accounted for in the isolated collateral's total debt exposure.
+   * @dev Only assets of the same family (eg USD stablecoins) should be borrowable in isolation mode to keep
+   * consistency in the debt ceiling calculations.
+   * @param self The reserve configuration
+   * @return The borrowable in isolation flag
+   */
+  function getBorrowableInIsolation(
+    DataTypes.ReserveConfigurationMap memory self
+  ) internal pure returns (bool) {
+    return (self.data & ~BORROWABLE_IN_ISOLATION_MASK) != 0;
+  }
+
+  /**
+   * @notice Sets the siloed borrowing flag for the reserve.
+   * @dev When this flag is set to true, users borrowing this asset will not be allowed to borrow any other asset.
+   * @param self The reserve configuration
+   * @param siloed True if the asset is siloed
+   */
+  function setSiloedBorrowing(
+    DataTypes.ReserveConfigurationMap memory self,
+    bool siloed
+  ) internal pure {
+    self.data =
+      (self.data & SILOED_BORROWING_MASK) |
+      (uint256(siloed ? 1 : 0) << SILOED_BORROWING_START_BIT_POSITION);
+  }
+
+  /**
+   * @notice Gets the siloed borrowing flag for the reserve.
+   * @dev When this flag is set to true, users borrowing this asset will not be allowed to borrow any other asset.
+   * @param self The reserve configuration
+   * @return The siloed borrowing flag
+   */
+  function getSiloedBorrowing(
+    DataTypes.ReserveConfigurationMap memory self
+  ) internal pure returns (bool) {
+    return (self.data & ~SILOED_BORROWING_MASK) != 0;
+  }
+
+  /**
+   * @notice Enables or disables borrowing on the reserve
+   * @param self The reserve configuration
+   * @param enabled True if the borrowing needs to be enabled, false otherwise
+   */
+  function setBorrowingEnabled(
+    DataTypes.ReserveConfigurationMap memory self,
+    bool enabled
+  ) internal pure {
+    self.data =
+      (self.data & BORROWING_MASK) |
+      (uint256(enabled ? 1 : 0) << BORROWING_ENABLED_START_BIT_POSITION);
+  }
+
+  /**
+   * @notice Gets the borrowing state of the reserve
+   * @param self The reserve configuration
+   * @return The borrowing state
+   */
+  function getBorrowingEnabled(
+    DataTypes.ReserveConfigurationMap memory self
+  ) external pure returns (bool) {
+    // certora munge external
+    return (self.data & ~BORROWING_MASK) != 0;
+  }
+
+  /**
+   * @notice Enables or disables stable rate borrowing on the reserve
+   * @param self The reserve configuration
+   * @param enabled True if the stable rate borrowing needs to be enabled, false otherwise
+   */
+  function setStableRateBorrowingEnabled(
+    DataTypes.ReserveConfigurationMap memory self,
+    bool enabled
+  ) internal pure {
+    self.data =
+      (self.data & STABLE_BORROWING_MASK) |
+      (uint256(enabled ? 1 : 0) << STABLE_BORROWING_ENABLED_START_BIT_POSITION);
+  }
+
+  /**
+   * @notice Gets the stable rate borrowing state of the reserve
+   * @param self The reserve configuration
+   * @return The stable rate borrowing state
+   */
+  function getStableRateBorrowingEnabled(
+    DataTypes.ReserveConfigurationMap memory self
+  ) internal pure returns (bool) {
+    return (self.data & ~STABLE_BORROWING_MASK) != 0;
+  }
+
+  /**
+   * @notice Sets the reserve factor of the reserve
+   * @param self The reserve configuration
+   * @param reserveFactor The reserve factor
+   */
+  function setReserveFactor(
+    DataTypes.ReserveConfigurationMap memory self,
+    uint256 reserveFactor
+  ) internal pure {
+    require(reserveFactor <= MAX_VALID_RESERVE_FACTOR, Errors.INVALID_RESERVE_FACTOR);
+
+    self.data =
+      (self.data & RESERVE_FACTOR_MASK) |
+      (reserveFactor << RESERVE_FACTOR_START_BIT_POSITION);
+  }
+
+  /**
+   * @notice Gets the reserve factor of the reserve
+   * @param self The reserve configuration
+   * @return The reserve factor
+   */
+  function getReserveFactor(
+    DataTypes.ReserveConfigurationMap memory self
+  ) internal pure returns (uint256) {
+    return (self.data & ~RESERVE_FACTOR_MASK) >> RESERVE_FACTOR_START_BIT_POSITION;
+  }
+
+  /**
+   * @notice Sets the borrow cap of the reserve
+   * @param self The reserve configuration
+   * @param borrowCap The borrow cap
+   */
+  function setBorrowCap(
+    DataTypes.ReserveConfigurationMap memory self,
+    uint256 borrowCap
+  ) internal pure {
+    require(borrowCap <= MAX_VALID_BORROW_CAP, Errors.INVALID_BORROW_CAP);
+
+    self.data = (self.data & BORROW_CAP_MASK) | (borrowCap << BORROW_CAP_START_BIT_POSITION);
+  }
+
+  /**
+   * @notice Gets the borrow cap of the reserve
+   * @param self The reserve configuration
+   * @return The borrow cap
+   */
+  function getBorrowCap(
+    DataTypes.ReserveConfigurationMap memory self
+  ) internal pure returns (uint256) {
+    return (self.data & ~BORROW_CAP_MASK) >> BORROW_CAP_START_BIT_POSITION;
+  }
+
+  /**
+   * @notice Sets the supply cap of the reserve
+   * @param self The reserve configuration
+   * @param supplyCap The supply cap
+   */
+  function setSupplyCap(
+    DataTypes.ReserveConfigurationMap memory self,
+    uint256 supplyCap
+  ) internal pure {
+    require(supplyCap <= MAX_VALID_SUPPLY_CAP, Errors.INVALID_SUPPLY_CAP);
+
+    self.data = (self.data & SUPPLY_CAP_MASK) | (supplyCap << SUPPLY_CAP_START_BIT_POSITION);
+  }
+
+  /**
+   * @notice Gets the supply cap of the reserve
+   * @param self The reserve configuration
+   * @return The supply cap
+   */
+  function getSupplyCap(
+    DataTypes.ReserveConfigurationMap memory self
+  ) internal pure returns (uint256) {
+    return (self.data & ~SUPPLY_CAP_MASK) >> SUPPLY_CAP_START_BIT_POSITION;
+  }
+
+  /**
+   * @notice Sets the debt ceiling in isolation mode for the asset
+   * @param self The reserve configuration
+   * @param ceiling The maximum debt ceiling for the asset
+   */
+  function setDebtCeiling(
+    DataTypes.ReserveConfigurationMap memory self,
+    uint256 ceiling
+  ) internal pure {
+    require(ceiling <= MAX_VALID_DEBT_CEILING, Errors.INVALID_DEBT_CEILING);
+
+    self.data = (self.data & DEBT_CEILING_MASK) | (ceiling << DEBT_CEILING_START_BIT_POSITION);
+  }
+
+  /**
+   * @notice Gets the debt ceiling for the asset if the asset is in isolation mode
+   * @param self The reserve configuration
+   * @return The debt ceiling (0 = isolation mode disabled)
+   */
+  function getDebtCeiling(
+    DataTypes.ReserveConfigurationMap memory self
+  ) internal pure returns (uint256) {
+    return (self.data & ~DEBT_CEILING_MASK) >> DEBT_CEILING_START_BIT_POSITION;
+  }
+
+  /**
+   * @notice Sets the liquidation protocol fee of the reserve
+   * @param self The reserve configuration
+   * @param liquidationProtocolFee The liquidation protocol fee
+   */
+  function setLiquidationProtocolFee(
+    DataTypes.ReserveConfigurationMap memory self,
+    uint256 liquidationProtocolFee
+  ) internal pure {
+    require(
+      liquidationProtocolFee <= MAX_VALID_LIQUIDATION_PROTOCOL_FEE,
+      Errors.INVALID_LIQUIDATION_PROTOCOL_FEE
+    );
+
+    self.data =
+      (self.data & LIQUIDATION_PROTOCOL_FEE_MASK) |
+      (liquidationProtocolFee << LIQUIDATION_PROTOCOL_FEE_START_BIT_POSITION);
+  }
+
+  /**
+   * @dev Gets the liquidation protocol fee
+   * @param self The reserve configuration
+   * @return The liquidation protocol fee
+   */
+  function getLiquidationProtocolFee(
+    DataTypes.ReserveConfigurationMap memory self
+  ) internal pure returns (uint256) {
+    return
+      (self.data & ~LIQUIDATION_PROTOCOL_FEE_MASK) >> LIQUIDATION_PROTOCOL_FEE_START_BIT_POSITION;
+  }
+
+  /**
+   * @notice Sets the unbacked mint cap of the reserve
+   * @param self The reserve configuration
+   * @param unbackedMintCap The unbacked mint cap
+   */
+  function setUnbackedMintCap(
+    DataTypes.ReserveConfigurationMap memory self,
+    uint256 unbackedMintCap
+  ) internal pure {
+    require(unbackedMintCap <= MAX_VALID_UNBACKED_MINT_CAP, Errors.INVALID_UNBACKED_MINT_CAP);
+
+    self.data =
+      (self.data & UNBACKED_MINT_CAP_MASK) |
+      (unbackedMintCap << UNBACKED_MINT_CAP_START_BIT_POSITION);
+  }
+
+  /**
+   * @dev Gets the unbacked mint cap of the reserve
+   * @param self The reserve configuration
+   * @return The unbacked mint cap
+   */
+  function getUnbackedMintCap(
+    DataTypes.ReserveConfigurationMap memory self
+  ) internal pure returns (uint256) {
+    return (self.data & ~UNBACKED_MINT_CAP_MASK) >> UNBACKED_MINT_CAP_START_BIT_POSITION;
+  }
+
+  /**
+   * @notice Sets the eMode asset category
+   * @param self The reserve configuration
+   * @param category The asset category when the user selects the eMode
+   */
+  function setEModeCategory(
+    DataTypes.ReserveConfigurationMap memory self,
+    uint256 category
+  ) internal pure {
+    require(category <= MAX_VALID_EMODE_CATEGORY, Errors.INVALID_EMODE_CATEGORY);
+
+    self.data = (self.data & EMODE_CATEGORY_MASK) | (category << EMODE_CATEGORY_START_BIT_POSITION);
+  }
+
+  /**
+   * @dev Gets the eMode asset category
+   * @param self The reserve configuration
+   * @return The eMode category for the asset
+   */
+  function getEModeCategory(
+    DataTypes.ReserveConfigurationMap memory self
+  ) internal pure returns (uint256) {
+    return (self.data & ~EMODE_CATEGORY_MASK) >> EMODE_CATEGORY_START_BIT_POSITION;
+  }
+
+  /**
+   * @notice Sets the flashloanable flag for the reserve
+   * @param self The reserve configuration
+   * @param flashLoanEnabled True if the asset is flashloanable, false otherwise
+   */
+  function setFlashLoanEnabled(
+    DataTypes.ReserveConfigurationMap memory self,
+    bool flashLoanEnabled
+  ) internal pure {
+    self.data =
+      (self.data & FLASHLOAN_ENABLED_MASK) |
+      (uint256(flashLoanEnabled ? 1 : 0) << FLASHLOAN_ENABLED_START_BIT_POSITION);
+  }
+
+  /**
+   * @notice Gets the flashloanable flag for the reserve
+   * @param self The reserve configuration
+   * @return The flashloanable flag
+   */
+  function getFlashLoanEnabled(
+    DataTypes.ReserveConfigurationMap memory self
+  ) internal pure returns (bool) {
+    return (self.data & ~FLASHLOAN_ENABLED_MASK) != 0;
+  }
+
+  /**
+   * @notice Gets the configuration flags of the reserve
+   * @param self The reserve configuration
+   * @return The state flag representing active
+   * @return The state flag representing frozen
+   * @return The state flag representing borrowing enabled
+   * @return The state flag representing stableRateBorrowing enabled
+   * @return The state flag representing paused
+   */
+  function getFlags(
+    DataTypes.ReserveConfigurationMap memory self
+  ) internal pure returns (bool, bool, bool, bool, bool) {
+    uint256 dataLocal = self.data;
+
+    return (
+      (dataLocal & ~ACTIVE_MASK) != 0,
+      (dataLocal & ~FROZEN_MASK) != 0,
+      (dataLocal & ~BORROWING_MASK) != 0,
+      (dataLocal & ~STABLE_BORROWING_MASK) != 0,
+      (dataLocal & ~PAUSED_MASK) != 0
+    );
+  }
+
+  /**
+   * @notice Gets the configuration parameters of the reserve from storage
+   * @param self The reserve configuration
+   * @return The state param representing ltv
+   * @return The state param representing liquidation threshold
+   * @return The state param representing liquidation bonus
+   * @return The state param representing reserve decimals
+   * @return The state param representing reserve factor
+   * @return The state param representing eMode category
+   */
+  function getParams(
+    DataTypes.ReserveConfigurationMap memory self
+  ) internal pure returns (uint256, uint256, uint256, uint256, uint256, uint256) {
+    uint256 dataLocal = self.data;
+
+    return (
+      dataLocal & ~LTV_MASK,
+      (dataLocal & ~LIQUIDATION_THRESHOLD_MASK) >> LIQUIDATION_THRESHOLD_START_BIT_POSITION,
+      (dataLocal & ~LIQUIDATION_BONUS_MASK) >> LIQUIDATION_BONUS_START_BIT_POSITION,
+      (dataLocal & ~DECIMALS_MASK) >> RESERVE_DECIMALS_START_BIT_POSITION,
+      (dataLocal & ~RESERVE_FACTOR_MASK) >> RESERVE_FACTOR_START_BIT_POSITION,
+      (dataLocal & ~EMODE_CATEGORY_MASK) >> EMODE_CATEGORY_START_BIT_POSITION
+    );
+  }
+
+  /**
+   * @notice Gets the caps parameters of the reserve from storage
+   * @param self The reserve configuration
+   * @return The state param representing borrow cap
+   * @return The state param representing supply cap.
+   */
+  function getCaps(
+    DataTypes.ReserveConfigurationMap memory self
+  ) internal pure returns (uint256, uint256) {
+    uint256 dataLocal = self.data;
+
+    return (
+      (dataLocal & ~BORROW_CAP_MASK) >> BORROW_CAP_START_BIT_POSITION,
+      (dataLocal & ~SUPPLY_CAP_MASK) >> SUPPLY_CAP_START_BIT_POSITION
+    );
+  }
+}
diff -ruN protocol/libraries/configuration/UserConfiguration.sol protocol/libraries/configuration/UserConfiguration.sol
--- protocol/libraries/configuration/UserConfiguration.sol	2023-09-15 08:31:43
+++ protocol/libraries/configuration/UserConfiguration.sol	2023-11-15 18:37:42
@@ -5,181 +5,120 @@
 import {DataTypes} from '../types/DataTypes.sol';
 import {ReserveConfiguration} from './ReserveConfiguration.sol';
 
-/**
- * @title UserConfiguration library
- * @author Aave
- * @notice Implements the bitmap logic to handle the user configuration
- */
 library UserConfiguration {
   using ReserveConfiguration for DataTypes.ReserveConfigurationMap;
+  uint16 public constant MAX_RESERVES_SUMMARY = 3;
 
-  uint256 internal constant BORROWING_MASK =
-    0x5555555555555555555555555555555555555555555555555555555555555555;
-  uint256 internal constant COLLATERAL_MASK =
-    0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
-
-  /**
-   * @notice Sets if the user is borrowing the reserve identified by reserveIndex
-   * @param self The configuration object
-   * @param reserveIndex The index of the reserve in the bitmap
-   * @param borrowing True if the user is borrowing the reserve, false otherwise
-   */
   function setBorrowing(
     DataTypes.UserConfigurationMap storage self,
     uint256 reserveIndex,
-    bool borrowing
-  ) internal {
-    unchecked {
+    bool borrowing) internal {
       require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
-      uint256 bit = 1 << (reserveIndex << 1);
-      if (borrowing) {
-        self.data |= bit;
-      } else {
-        self.data &= ~bit;
-      }
-    }
+      require(reserveIndex < MAX_RESERVES_SUMMARY, "Too mamy reserves for this summary");
+      if (reserveIndex == 0) { self.isBorrowing0 = borrowing; }
+      if (reserveIndex == 1) { self.isBorrowing1 = borrowing; }
+      if (reserveIndex == 2) { self.isBorrowing2 = borrowing; }
   }
 
-  /**
-   * @notice Sets if the user is using as collateral the reserve identified by reserveIndex
-   * @param self The configuration object
-   * @param reserveIndex The index of the reserve in the bitmap
-   * @param usingAsCollateral True if the user is using the reserve as collateral, false otherwise
-   */
   function setUsingAsCollateral(
     DataTypes.UserConfigurationMap storage self,
     uint256 reserveIndex,
     bool usingAsCollateral
   ) internal {
-    unchecked {
       require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
-      uint256 bit = 1 << ((reserveIndex << 1) + 1);
-      if (usingAsCollateral) {
-        self.data |= bit;
-      } else {
-        self.data &= ~bit;
-      }
-    }
+      require(reserveIndex < MAX_RESERVES_SUMMARY, "Too mamy reserves for this summary");
+      if (reserveIndex == 0) { self.isUsingAsCollateral0 = usingAsCollateral; }
+      if (reserveIndex == 1) { self.isUsingAsCollateral1 = usingAsCollateral; }
+      if (reserveIndex == 2) { self.isUsingAsCollateral2 = usingAsCollateral; }
   }
 
-  /**
-   * @notice Returns if a user has been using the reserve for borrowing or as collateral
-   * @param self The configuration object
-   * @param reserveIndex The index of the reserve in the bitmap
-   * @return True if the user has been using a reserve for borrowing or as collateral, false otherwise
-   */
   function isUsingAsCollateralOrBorrowing(
     DataTypes.UserConfigurationMap memory self,
     uint256 reserveIndex
   ) internal pure returns (bool) {
-    unchecked {
-      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
-      return (self.data >> (reserveIndex << 1)) & 3 != 0;
-    }
+    require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
+      require(reserveIndex < MAX_RESERVES_SUMMARY, "Too mamy reserves for this summary");
+      if (reserveIndex == 0) { return self.isBorrowing0 || self.isUsingAsCollateral0; }
+      if (reserveIndex == 1) { return self.isBorrowing1 || self.isUsingAsCollateral1; }
+      if (reserveIndex == 2) { return self.isBorrowing2 || self.isUsingAsCollateral2; }
+
+      require(false, "error fallback");
+      return false;
   }
 
-  /**
-   * @notice Validate a user has been using the reserve for borrowing
-   * @param self The configuration object
-   * @param reserveIndex The index of the reserve in the bitmap
-   * @return True if the user has been using a reserve for borrowing, false otherwise
-   */
   function isBorrowing(
     DataTypes.UserConfigurationMap memory self,
     uint256 reserveIndex
   ) internal pure returns (bool) {
-    unchecked {
       require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
-      return (self.data >> (reserveIndex << 1)) & 1 != 0;
-    }
+      require(reserveIndex < MAX_RESERVES_SUMMARY, "Too mamy reserves for this summary");
+      if (reserveIndex == 0) { return self.isBorrowing0; }
+      if (reserveIndex == 1) { return self.isBorrowing1; }
+      if (reserveIndex == 2) { return self.isBorrowing2; }
+      
+      require(false, "error fallback");
+      return false;
   }
-
-  /**
-   * @notice Validate a user has been using the reserve as collateral
-   * @param self The configuration object
-   * @param reserveIndex The index of the reserve in the bitmap
-   * @return True if the user has been using a reserve as collateral, false otherwise
-   */
+  
   function isUsingAsCollateral(
     DataTypes.UserConfigurationMap memory self,
     uint256 reserveIndex
   ) internal pure returns (bool) {
-    unchecked {
-      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
-      return (self.data >> ((reserveIndex << 1) + 1)) & 1 != 0;
-    }
+    require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
+      require(reserveIndex < MAX_RESERVES_SUMMARY, "Too mamy reserves for this summary");
+      if (reserveIndex == 0) { return self.isUsingAsCollateral0; }
+      if (reserveIndex == 1) { return self.isUsingAsCollateral1; }
+      if (reserveIndex == 2) { return self.isUsingAsCollateral2; }
+
+      require(false, "error fallback");
+      return false;
   }
 
-  /**
-   * @notice Checks if a user has been supplying only one reserve as collateral
-   * @dev this uses a simple trick - if a number is a power of two (only one bit set) then n & (n - 1) == 0
-   * @param self The configuration object
-   * @return True if the user has been supplying as collateral one reserve, false otherwise
-   */
   function isUsingAsCollateralOne(
     DataTypes.UserConfigurationMap memory self
   ) internal pure returns (bool) {
-    uint256 collateralData = self.data & COLLATERAL_MASK;
-    return collateralData != 0 && (collateralData & (collateralData - 1) == 0);
+    return 
+      (self.isUsingAsCollateral0 && 
+        !self.isUsingAsCollateral1 && 
+        !self.isUsingAsCollateral2) ||
+      (!self.isUsingAsCollateral0 && 
+        self.isUsingAsCollateral1 && 
+        !self.isUsingAsCollateral2) ||
+      (!self.isUsingAsCollateral0 && 
+        !self.isUsingAsCollateral1 && 
+        self.isUsingAsCollateral2);
   }
 
-  /**
-   * @notice Checks if a user has been supplying any reserve as collateral
-   * @param self The configuration object
-   * @return True if the user has been supplying as collateral any reserve, false otherwise
-   */
   function isUsingAsCollateralAny(
     DataTypes.UserConfigurationMap memory self
   ) internal pure returns (bool) {
-    return self.data & COLLATERAL_MASK != 0;
+    return self.isUsingAsCollateral0 || 
+      self.isUsingAsCollateral1 || self.isUsingAsCollateral2;
   }
 
-  /**
-   * @notice Checks if a user has been borrowing only one asset
-   * @dev this uses a simple trick - if a number is a power of two (only one bit set) then n & (n - 1) == 0
-   * @param self The configuration object
-   * @return True if the user has been supplying as collateral one reserve, false otherwise
-   */
   function isBorrowingOne(DataTypes.UserConfigurationMap memory self) internal pure returns (bool) {
-    uint256 borrowingData = self.data & BORROWING_MASK;
-    return borrowingData != 0 && (borrowingData & (borrowingData - 1) == 0);
+    return 
+      (self.isBorrowing0 && !self.isBorrowing1 && !self.isBorrowing2) ||
+      (!self.isBorrowing0 && self.isBorrowing1 && !self.isBorrowing2) ||
+      (!self.isBorrowing0 && !self.isBorrowing1 && self.isBorrowing2);
   }
 
-  /**
-   * @notice Checks if a user has been borrowing from any reserve
-   * @param self The configuration object
-   * @return True if the user has been borrowing any reserve, false otherwise
-   */
   function isBorrowingAny(DataTypes.UserConfigurationMap memory self) internal pure returns (bool) {
-    return self.data & BORROWING_MASK != 0;
+    return self.isBorrowing0 || self.isBorrowing1 || self.isBorrowing2;
   }
 
-  /**
-   * @notice Checks if a user has not been using any reserve for borrowing or supply
-   * @param self The configuration object
-   * @return True if the user has not been borrowing or supplying any reserve, false otherwise
-   */
   function isEmpty(DataTypes.UserConfigurationMap memory self) internal pure returns (bool) {
-    return self.data == 0;
+    return !self.isBorrowing0 && !self.isBorrowing1 && !self.isBorrowing2 &&
+      !self.isUsingAsCollateral0 && !self.isUsingAsCollateral1 && !self.isUsingAsCollateral2;
   }
 
-  /**
-   * @notice Returns the Isolation Mode state of the user
-   * @param self The configuration object
-   * @param reservesData The state of all the reserves
-   * @param reservesList The addresses of all the active reserves
-   * @return True if the user is in isolation mode, false otherwise
-   * @return The address of the only asset used as collateral
-   * @return The debt ceiling of the reserve
-   */
   function getIsolationModeState(
     DataTypes.UserConfigurationMap memory self,
     mapping(address => DataTypes.ReserveData) storage reservesData,
     mapping(uint256 => address) storage reservesList
   ) internal view returns (bool, address, uint256) {
     if (isUsingAsCollateralOne(self)) {
-      uint256 assetId = _getFirstAssetIdByMask(self, COLLATERAL_MASK);
-
+      uint256 assetId = _getFirstUsingAsCollateralAssetID(self);
       address assetAddress = reservesList[assetId];
       uint256 ceiling = reservesData[assetAddress].configuration.getDebtCeiling();
       if (ceiling != 0) {
@@ -189,48 +128,41 @@
     return (false, address(0), 0);
   }
 
-  /**
-   * @notice Returns the siloed borrowing state for the user
-   * @param self The configuration object
-   * @param reservesData The data of all the reserves
-   * @param reservesList The reserve list
-   * @return True if the user has borrowed a siloed asset, false otherwise
-   * @return The address of the only borrowed asset
-   */
   function getSiloedBorrowingState(
     DataTypes.UserConfigurationMap memory self,
     mapping(address => DataTypes.ReserveData) storage reservesData,
     mapping(uint256 => address) storage reservesList
   ) internal view returns (bool, address) {
     if (isBorrowingOne(self)) {
-      uint256 assetId = _getFirstAssetIdByMask(self, BORROWING_MASK);
+      uint256 assetId = _getFirstBorrowingAssetID(self);
       address assetAddress = reservesList[assetId];
       if (reservesData[assetAddress].configuration.getSiloedBorrowing()) {
         return (true, assetAddress);
       }
     }
-
     return (false, address(0));
   }
 
-  /**
-   * @notice Returns the address of the first asset flagged in the bitmap given the corresponding bitmask
-   * @param self The configuration object
-   * @return The index of the first asset flagged in the bitmap once the corresponding mask is applied
-   */
-  function _getFirstAssetIdByMask(
-    DataTypes.UserConfigurationMap memory self,
-    uint256 mask
+  function _getFirstBorrowingAssetID(
+    DataTypes.UserConfigurationMap memory self
   ) internal pure returns (uint256) {
-    unchecked {
-      uint256 bitmapData = self.data & mask;
-      uint256 firstAssetPosition = bitmapData & ~(bitmapData - 1);
-      uint256 id;
-
-      while ((firstAssetPosition >>= 2) != 0) {
-        id += 1;
-      }
-      return id;
-    }
+    if (self.isBorrowing0) { return 0; }
+    if (self.isBorrowing1) { return 1; }
+    if (self.isBorrowing2) { return 2; }
+    
+    require(false, "error fallback");
+    return MAX_RESERVES_SUMMARY;
   }
+
+function _getFirstUsingAsCollateralAssetID(
+    DataTypes.UserConfigurationMap memory self
+  ) internal pure returns (uint256) {
+    if (self.isUsingAsCollateral0) { return 0; }
+    if (self.isUsingAsCollateral1) { return 1; }
+    if (self.isUsingAsCollateral2) { return 2; }
+
+    require(false, "error fallback");
+    return MAX_RESERVES_SUMMARY;
+}
+
 }
diff -ruN protocol/libraries/configuration/UserConfiguration_noBV.sol protocol/libraries/configuration/UserConfiguration_noBV.sol
--- protocol/libraries/configuration/UserConfiguration_noBV.sol	1970-01-01 01:00:00
+++ protocol/libraries/configuration/UserConfiguration_noBV.sol	2023-11-20 09:12:19
@@ -0,0 +1,153 @@
+// SPDX-License-Identifier: BUSL-1.1
+pragma solidity ^0.8.0;
+
+import {Errors} from '../helpers/Errors.sol';
+import {DataTypes} from '../types/DataTypes.sol';
+import {ReserveConfiguration} from './ReserveConfiguration.sol';
+
+library UserConfiguration {
+  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;
+
+  function setBorrowing(
+    DataTypes.UserConfigurationMap storage self,
+    uint256 reserveIndex,
+    bool borrowing) internal {
+      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
+      bool borrowingBefore = self.isBorrowing[reserveIndex];
+      if (borrowingBefore != borrowing) {
+        if (borrowing) self.borrowingCount++;  
+        else self.borrowingCount--;
+        self.isBorrowing[reserveIndex] = borrowing;
+      }
+  }
+
+  function setUsingAsCollateral(
+    DataTypes.UserConfigurationMap storage self,
+    uint256 reserveIndex,
+    bool usingAsCollateral
+  ) internal {
+      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
+      bool usingAsCollateralBefore = self.isUsingAsCollateral[reserveIndex];
+      if (usingAsCollateral != usingAsCollateralBefore) {
+        if (usingAsCollateral) self.usingAsCollateralCount++;  
+        else self.usingAsCollateralCount--;
+        self.isUsingAsCollateral[reserveIndex] = usingAsCollateral;
+      }
+  }
+
+  function isUsingAsCollateralOrBorrowing(
+    DataTypes.UserConfigurationMap memory self,
+    uint256 reserveIndex
+  ) internal pure returns (bool) {
+    require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
+    return self.isBorrowing[reserveIndex] || self.isUsingAsCollateral[reserveIndex];
+  }
+
+  function isBorrowing(
+    DataTypes.UserConfigurationMap memory self,
+    uint256 reserveIndex
+  ) internal pure returns (bool) {
+      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
+      return self.isBorrowing[reserveIndex];
+  }
+  
+  function isUsingAsCollateral(
+    DataTypes.UserConfigurationMap memory self,
+    uint256 reserveIndex
+  ) internal pure returns (bool) {
+    require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
+    return self.isUsingAsCollateral[reserveIndex];
+  }
+
+  function isUsingAsCollateralOne(
+    DataTypes.UserConfigurationMap memory self
+  ) internal pure returns (bool) {
+    return self.usingAsCollateralCount == 1;
+  }
+
+  function isUsingAsCollateralAny(
+    DataTypes.UserConfigurationMap memory self
+  ) internal pure returns (bool) {
+    return self.usingAsCollateralCount > 0;
+  }
+
+  function isBorrowingOne(DataTypes.UserConfigurationMap memory self) internal pure returns (bool) {
+    return self.borrowingCount == 1;
+  }
+
+  function isBorrowingAny(DataTypes.UserConfigurationMap memory self) internal pure returns (bool) {
+    return self.borrowingCount > 0;
+  }
+
+  function isEmpty(DataTypes.UserConfigurationMap memory self) internal pure returns (bool) {
+    return self.borrowingCount == 0 && self.usingAsCollateralCount == 0;
+  }
+
+  function getIsolationModeState(
+    DataTypes.UserConfigurationMap memory self,
+    mapping(address => DataTypes.ReserveData) storage reservesData,
+    mapping(uint256 => address) storage reservesList
+  ) internal view returns (bool, address, uint256) {
+    if (isUsingAsCollateralOne(self)) {
+      uint256 assetId = _getFirstUsingAsCollateralAssetID(self);
+      address assetAddress = reservesList[assetId];
+      uint256 ceiling = reservesData[assetAddress].configuration.getDebtCeiling();
+      if (ceiling != 0) {
+        return (true, assetAddress, ceiling);
+      }
+    }
+    return (false, address(0), 0);
+  }
+
+  function getSiloedBorrowingState(
+    DataTypes.UserConfigurationMap memory self,
+    mapping(address => DataTypes.ReserveData) storage reservesData,
+    mapping(uint256 => address) storage reservesList
+  ) internal view returns (bool, address) {
+    if (isBorrowingOne(self)) {
+      uint256 assetId = _getFirstBorrowingAssetID(self);
+      address assetAddress = reservesList[assetId];
+      if (reservesData[assetAddress].configuration.getSiloedBorrowing()) {
+        return (true, assetAddress);
+      }
+    }
+    return (false, address(0));
+  }
+
+  function _getFirstBorrowingAssetID(
+    DataTypes.UserConfigurationMap memory self
+  ) internal pure returns (uint256) {
+    for (uint i = 0; i < ReserveConfiguration.MAX_RESERVES_COUNT; i++) {
+        if (self.isBorrowing[i]) { return i; }
+    }
+    return ReserveConfiguration.MAX_RESERVES_COUNT; //error fallback
+}
+
+function _getFirstUsingAsCollateralAssetID(
+    DataTypes.UserConfigurationMap memory self
+  ) internal pure returns (uint256) {
+    for (uint i = 0; i < ReserveConfiguration.MAX_RESERVES_COUNT; i++) {
+        if (self.isUsingAsCollateral[i]) { return i; }
+    }
+    return ReserveConfiguration.MAX_RESERVES_COUNT; //error fallback
+}
+
+function _isValidState(
+    DataTypes.UserConfigurationMap memory self
+  ) internal pure returns (bool) {
+    bool correctSize = 
+        self.isBorrowing.length == ReserveConfiguration.MAX_RESERVES_COUNT &&
+        self.isUsingAsCollateral.length == ReserveConfiguration.MAX_RESERVES_COUNT;
+    if (!correctSize) { return false; } 
+    //we require equality to be able to scale the complexity by modifying MAX_RESERVES_COUNT
+
+    uint borrowingAssetsCount = 0;
+    uint usingAsCollateralAssetsCount = 0;
+    for (uint i = 0; i < ReserveConfiguration.MAX_RESERVES_COUNT; i++) {
+        if (self.isUsingAsCollateral[i]) { usingAsCollateralAssetsCount++; }
+        if (self.isBorrowing[i]) { borrowingAssetsCount++; }
+    }
+    return self.borrowingCount == borrowingAssetsCount && 
+        self.usingAsCollateralCount == usingAsCollateralAssetsCount;
+}
+}
diff -ruN protocol/libraries/configuration/UserConfiguration_noBV_3reserves.sol protocol/libraries/configuration/UserConfiguration_noBV_3reserves.sol
--- protocol/libraries/configuration/UserConfiguration_noBV_3reserves.sol	1970-01-01 01:00:00
+++ protocol/libraries/configuration/UserConfiguration_noBV_3reserves.sol	2023-11-20 09:12:19
@@ -0,0 +1,168 @@
+// SPDX-License-Identifier: BUSL-1.1
+pragma solidity ^0.8.0;
+
+import {Errors} from '../helpers/Errors.sol';
+import {DataTypes} from '../types/DataTypes.sol';
+import {ReserveConfiguration} from './ReserveConfiguration.sol';
+
+library UserConfiguration {
+  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;
+  uint16 public constant MAX_RESERVES_SUMMARY = 3;
+
+  function setBorrowing(
+    DataTypes.UserConfigurationMap storage self,
+    uint256 reserveIndex,
+    bool borrowing) internal {
+      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
+      require(reserveIndex < MAX_RESERVES_SUMMARY, "Too mamy reserves for this summary");
+      if (reserveIndex == 0) { self.isBorrowing0 = borrowing; }
+      if (reserveIndex == 1) { self.isBorrowing1 = borrowing; }
+      if (reserveIndex == 2) { self.isBorrowing2 = borrowing; }
+  }
+
+  function setUsingAsCollateral(
+    DataTypes.UserConfigurationMap storage self,
+    uint256 reserveIndex,
+    bool usingAsCollateral
+  ) internal {
+      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
+      require(reserveIndex < MAX_RESERVES_SUMMARY, "Too mamy reserves for this summary");
+      if (reserveIndex == 0) { self.isUsingAsCollateral0 = usingAsCollateral; }
+      if (reserveIndex == 1) { self.isUsingAsCollateral1 = usingAsCollateral; }
+      if (reserveIndex == 2) { self.isUsingAsCollateral2 = usingAsCollateral; }
+  }
+
+  function isUsingAsCollateralOrBorrowing(
+    DataTypes.UserConfigurationMap memory self,
+    uint256 reserveIndex
+  ) internal pure returns (bool) {
+    require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
+      require(reserveIndex < MAX_RESERVES_SUMMARY, "Too mamy reserves for this summary");
+      if (reserveIndex == 0) { return self.isBorrowing0 || self.isUsingAsCollateral0; }
+      if (reserveIndex == 1) { return self.isBorrowing1 || self.isUsingAsCollateral1; }
+      if (reserveIndex == 2) { return self.isBorrowing2 || self.isUsingAsCollateral2; }
+
+      require(false, "error fallback");
+      return false;
+  }
+
+  function isBorrowing(
+    DataTypes.UserConfigurationMap memory self,
+    uint256 reserveIndex
+  ) internal pure returns (bool) {
+      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
+      require(reserveIndex < MAX_RESERVES_SUMMARY, "Too mamy reserves for this summary");
+      if (reserveIndex == 0) { return self.isBorrowing0; }
+      if (reserveIndex == 1) { return self.isBorrowing1; }
+      if (reserveIndex == 2) { return self.isBorrowing2; }
+      
+      require(false, "error fallback");
+      return false;
+  }
+  
+  function isUsingAsCollateral(
+    DataTypes.UserConfigurationMap memory self,
+    uint256 reserveIndex
+  ) internal pure returns (bool) {
+    require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
+      require(reserveIndex < MAX_RESERVES_SUMMARY, "Too mamy reserves for this summary");
+      if (reserveIndex == 0) { return self.isUsingAsCollateral0; }
+      if (reserveIndex == 1) { return self.isUsingAsCollateral1; }
+      if (reserveIndex == 2) { return self.isUsingAsCollateral2; }
+
+      require(false, "error fallback");
+      return false;
+  }
+
+  function isUsingAsCollateralOne(
+    DataTypes.UserConfigurationMap memory self
+  ) internal pure returns (bool) {
+    return 
+      (self.isUsingAsCollateral0 && 
+        !self.isUsingAsCollateral1 && 
+        !self.isUsingAsCollateral2) ||
+      (!self.isUsingAsCollateral0 && 
+        self.isUsingAsCollateral1 && 
+        !self.isUsingAsCollateral2) ||
+      (!self.isUsingAsCollateral0 && 
+        !self.isUsingAsCollateral1 && 
+        self.isUsingAsCollateral2);
+  }
+
+  function isUsingAsCollateralAny(
+    DataTypes.UserConfigurationMap memory self
+  ) internal pure returns (bool) {
+    return self.isUsingAsCollateral0 || 
+      self.isUsingAsCollateral1 || self.isUsingAsCollateral2;
+  }
+
+  function isBorrowingOne(DataTypes.UserConfigurationMap memory self) internal pure returns (bool) {
+    return 
+      (self.isBorrowing0 && !self.isBorrowing1 && !self.isBorrowing2) ||
+      (!self.isBorrowing0 && self.isBorrowing1 && !self.isBorrowing2) ||
+      (!self.isBorrowing0 && !self.isBorrowing1 && self.isBorrowing2);
+  }
+
+  function isBorrowingAny(DataTypes.UserConfigurationMap memory self) internal pure returns (bool) {
+    return self.isBorrowing0 || self.isBorrowing1 || self.isBorrowing2;
+  }
+
+  function isEmpty(DataTypes.UserConfigurationMap memory self) internal pure returns (bool) {
+    return !self.isBorrowing0 && !self.isBorrowing1 && !self.isBorrowing2 &&
+      !self.isUsingAsCollateral0 && !self.isUsingAsCollateral1 && !self.isUsingAsCollateral2;
+  }
+
+  function getIsolationModeState(
+    DataTypes.UserConfigurationMap memory self,
+    mapping(address => DataTypes.ReserveData) storage reservesData,
+    mapping(uint256 => address) storage reservesList
+  ) internal view returns (bool, address, uint256) {
+    if (isUsingAsCollateralOne(self)) {
+      uint256 assetId = _getFirstUsingAsCollateralAssetID(self);
+      address assetAddress = reservesList[assetId];
+      uint256 ceiling = reservesData[assetAddress].configuration.getDebtCeiling();
+      if (ceiling != 0) {
+        return (true, assetAddress, ceiling);
+      }
+    }
+    return (false, address(0), 0);
+  }
+
+  function getSiloedBorrowingState(
+    DataTypes.UserConfigurationMap memory self,
+    mapping(address => DataTypes.ReserveData) storage reservesData,
+    mapping(uint256 => address) storage reservesList
+  ) internal view returns (bool, address) {
+    if (isBorrowingOne(self)) {
+      uint256 assetId = _getFirstBorrowingAssetID(self);
+      address assetAddress = reservesList[assetId];
+      if (reservesData[assetAddress].configuration.getSiloedBorrowing()) {
+        return (true, assetAddress);
+      }
+    }
+    return (false, address(0));
+  }
+
+  function _getFirstBorrowingAssetID(
+    DataTypes.UserConfigurationMap memory self
+  ) internal pure returns (uint256) {
+    if (self.isBorrowing0) { return 0; }
+    if (self.isBorrowing1) { return 1; }
+    if (self.isBorrowing2) { return 2; }
+    
+    require(false, "error fallback");
+    return MAX_RESERVES_SUMMARY;
+  }
+
+function _getFirstUsingAsCollateralAssetID(
+    DataTypes.UserConfigurationMap memory self
+  ) internal pure returns (uint256) {
+    if (self.isUsingAsCollateral0) { return 0; }
+    if (self.isUsingAsCollateral1) { return 1; }
+    if (self.isUsingAsCollateral2) { return 2; }
+
+    require(false, "error fallback");
+    return MAX_RESERVES_SUMMARY;
+}
+
+}
diff -ruN protocol/libraries/configuration/UserConfiguration_orig.sol protocol/libraries/configuration/UserConfiguration_orig.sol
--- protocol/libraries/configuration/UserConfiguration_orig.sol	1970-01-01 01:00:00
+++ protocol/libraries/configuration/UserConfiguration_orig.sol	2023-11-20 09:12:19
@@ -0,0 +1,236 @@
+// SPDX-License-Identifier: BUSL-1.1
+pragma solidity ^0.8.0;
+
+import {Errors} from '../helpers/Errors.sol';
+import {DataTypes} from '../types/DataTypes.sol';
+import {ReserveConfiguration} from './ReserveConfiguration.sol';
+
+/**
+ * @title UserConfiguration library
+ * @author Aave
+ * @notice Implements the bitmap logic to handle the user configuration
+ */
+library UserConfiguration {
+  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;
+
+  uint256 internal constant BORROWING_MASK =
+    0x5555555555555555555555555555555555555555555555555555555555555555;
+  uint256 internal constant COLLATERAL_MASK =
+    0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
+
+  /**
+   * @notice Sets if the user is borrowing the reserve identified by reserveIndex
+   * @param self The configuration object
+   * @param reserveIndex The index of the reserve in the bitmap
+   * @param borrowing True if the user is borrowing the reserve, false otherwise
+   */
+  function setBorrowing(
+    DataTypes.UserConfigurationMap storage self,
+    uint256 reserveIndex,
+    bool borrowing
+  ) internal {
+    unchecked {
+      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
+      uint256 bit = 1 << (reserveIndex << 1);
+      if (borrowing) {
+        self.data |= bit;
+      } else {
+        self.data &= ~bit;
+      }
+    }
+  }
+
+  /**
+   * @notice Sets if the user is using as collateral the reserve identified by reserveIndex
+   * @param self The configuration object
+   * @param reserveIndex The index of the reserve in the bitmap
+   * @param usingAsCollateral True if the user is using the reserve as collateral, false otherwise
+   */
+  function setUsingAsCollateral(
+    DataTypes.UserConfigurationMap storage self,
+    uint256 reserveIndex,
+    bool usingAsCollateral
+  ) internal {
+    unchecked {
+      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
+      uint256 bit = 1 << ((reserveIndex << 1) + 1);
+      if (usingAsCollateral) {
+        self.data |= bit;
+      } else {
+        self.data &= ~bit;
+      }
+    }
+  }
+
+  /**
+   * @notice Returns if a user has been using the reserve for borrowing or as collateral
+   * @param self The configuration object
+   * @param reserveIndex The index of the reserve in the bitmap
+   * @return True if the user has been using a reserve for borrowing or as collateral, false otherwise
+   */
+  function isUsingAsCollateralOrBorrowing(
+    DataTypes.UserConfigurationMap memory self,
+    uint256 reserveIndex
+  ) internal pure returns (bool) {
+    unchecked {
+      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
+      return (self.data >> (reserveIndex << 1)) & 3 != 0;
+    }
+  }
+
+  /**
+   * @notice Validate a user has been using the reserve for borrowing
+   * @param self The configuration object
+   * @param reserveIndex The index of the reserve in the bitmap
+   * @return True if the user has been using a reserve for borrowing, false otherwise
+   */
+  function isBorrowing(
+    DataTypes.UserConfigurationMap memory self,
+    uint256 reserveIndex
+  ) internal pure returns (bool) {
+    unchecked {
+      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
+      return (self.data >> (reserveIndex << 1)) & 1 != 0;
+    }
+  }
+
+  /**
+   * @notice Validate a user has been using the reserve as collateral
+   * @param self The configuration object
+   * @param reserveIndex The index of the reserve in the bitmap
+   * @return True if the user has been using a reserve as collateral, false otherwise
+   */
+  function isUsingAsCollateral(
+    DataTypes.UserConfigurationMap memory self,
+    uint256 reserveIndex
+  ) internal pure returns (bool) {
+    unchecked {
+      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
+      return (self.data >> ((reserveIndex << 1) + 1)) & 1 != 0;
+    }
+  }
+
+  /**
+   * @notice Checks if a user has been supplying only one reserve as collateral
+   * @dev this uses a simple trick - if a number is a power of two (only one bit set) then n & (n - 1) == 0
+   * @param self The configuration object
+   * @return True if the user has been supplying as collateral one reserve, false otherwise
+   */
+  function isUsingAsCollateralOne(
+    DataTypes.UserConfigurationMap memory self
+  ) internal pure returns (bool) {
+    uint256 collateralData = self.data & COLLATERAL_MASK;
+    return collateralData != 0 && (collateralData & (collateralData - 1) == 0);
+  }
+
+  /**
+   * @notice Checks if a user has been supplying any reserve as collateral
+   * @param self The configuration object
+   * @return True if the user has been supplying as collateral any reserve, false otherwise
+   */
+  function isUsingAsCollateralAny(
+    DataTypes.UserConfigurationMap memory self
+  ) internal pure returns (bool) {
+    return self.data & COLLATERAL_MASK != 0;
+  }
+
+  /**
+   * @notice Checks if a user has been borrowing only one asset
+   * @dev this uses a simple trick - if a number is a power of two (only one bit set) then n & (n - 1) == 0
+   * @param self The configuration object
+   * @return True if the user has been supplying as collateral one reserve, false otherwise
+   */
+  function isBorrowingOne(DataTypes.UserConfigurationMap memory self) internal pure returns (bool) {
+    uint256 borrowingData = self.data & BORROWING_MASK;
+    return borrowingData != 0 && (borrowingData & (borrowingData - 1) == 0);
+  }
+
+  /**
+   * @notice Checks if a user has been borrowing from any reserve
+   * @param self The configuration object
+   * @return True if the user has been borrowing any reserve, false otherwise
+   */
+  function isBorrowingAny(DataTypes.UserConfigurationMap memory self) internal pure returns (bool) {
+    return self.data & BORROWING_MASK != 0;
+  }
+
+  /**
+   * @notice Checks if a user has not been using any reserve for borrowing or supply
+   * @param self The configuration object
+   * @return True if the user has not been borrowing or supplying any reserve, false otherwise
+   */
+  function isEmpty(DataTypes.UserConfigurationMap memory self) internal pure returns (bool) {
+    return self.data == 0;
+  }
+
+  /**
+   * @notice Returns the Isolation Mode state of the user
+   * @param self The configuration object
+   * @param reservesData The state of all the reserves
+   * @param reservesList The addresses of all the active reserves
+   * @return True if the user is in isolation mode, false otherwise
+   * @return The address of the only asset used as collateral
+   * @return The debt ceiling of the reserve
+   */
+  function getIsolationModeState(
+    DataTypes.UserConfigurationMap memory self,
+    mapping(address => DataTypes.ReserveData) storage reservesData,
+    mapping(uint256 => address) storage reservesList
+  ) internal view returns (bool, address, uint256) {
+    if (isUsingAsCollateralOne(self)) {
+      uint256 assetId = _getFirstAssetIdByMask(self, COLLATERAL_MASK);
+
+      address assetAddress = reservesList[assetId];
+      uint256 ceiling = reservesData[assetAddress].configuration.getDebtCeiling();
+      if (ceiling != 0) {
+        return (true, assetAddress, ceiling);
+      }
+    }
+    return (false, address(0), 0);
+  }
+
+  /**
+   * @notice Returns the siloed borrowing state for the user
+   * @param self The configuration object
+   * @param reservesData The data of all the reserves
+   * @param reservesList The reserve list
+   * @return True if the user has borrowed a siloed asset, false otherwise
+   * @return The address of the only borrowed asset
+   */
+  function getSiloedBorrowingState(
+    DataTypes.UserConfigurationMap memory self,
+    mapping(address => DataTypes.ReserveData) storage reservesData,
+    mapping(uint256 => address) storage reservesList
+  ) internal view returns (bool, address) {
+    if (isBorrowingOne(self)) {
+      uint256 assetId = _getFirstAssetIdByMask(self, BORROWING_MASK);
+      address assetAddress = reservesList[assetId];
+      if (reservesData[assetAddress].configuration.getSiloedBorrowing()) {
+        return (true, assetAddress);
+      }
+    }
+
+    return (false, address(0));
+  }
+
+  /**
+   * @notice Returns the address of the first asset flagged in the bitmap given the corresponding bitmask
+   * @param self The configuration object
+   * @return The index of the first asset flagged in the bitmap once the corresponding mask is applied
+   */
+  function _getFirstAssetIdByMask(
+    DataTypes.UserConfigurationMap memory self,
+    uint256 mask
+  ) internal pure returns (uint256) {
+    unchecked {
+      uint256 bitmapData = self.data & mask;
+      uint256 firstAssetPosition = bitmapData & ~(bitmapData - 1);
+      uint256 id;
+
+      while ((firstAssetPosition >>= 2) != 0) {
+        id += 1;
+      }
+      return id;
+    }
+  }
+}
diff -ruN protocol/libraries/types/DataTypes_noBV.sol protocol/libraries/types/DataTypes_noBV.sol
--- protocol/libraries/types/DataTypes_noBV.sol	1970-01-01 01:00:00
+++ protocol/libraries/types/DataTypes_noBV.sol	2023-11-20 09:12:19
@@ -0,0 +1,317 @@
+// SPDX-License-Identifier: BUSL-1.1
+pragma solidity ^0.8.0;
+
+library DataTypes {
+  struct ReserveData {
+    //stores the reserve configuration
+    ReserveConfigurationMap configuration;
+    //the liquidity index. Expressed in ray
+    uint128 liquidityIndex;
+    //the current supply rate. Expressed in ray
+    uint128 currentLiquidityRate;
+    //variable borrow index. Expressed in ray
+    uint128 variableBorrowIndex;
+    //the current variable borrow rate. Expressed in ray
+    uint128 currentVariableBorrowRate;
+    //the current stable borrow rate. Expressed in ray
+    uint128 currentStableBorrowRate;
+    //timestamp of last update
+    uint40 lastUpdateTimestamp;
+    //the id of the reserve. Represents the position in the list of the active reserves
+    uint16 id;
+    //aToken address
+    address aTokenAddress;
+    //stableDebtToken address
+    address stableDebtTokenAddress;
+    //variableDebtToken address
+    address variableDebtTokenAddress;
+    //address of the interest rate strategy
+    address interestRateStrategyAddress;
+    //the current treasury balance, scaled
+    uint128 accruedToTreasury;
+    //the outstanding unbacked aTokens minted through the bridging feature
+    uint128 unbacked;
+    //the outstanding debt borrowed against this asset in isolation mode
+    uint128 isolationModeTotalDebt;
+  }
+
+struct ReserveConfigurationMap {
+    uint256 data; //original data
+    // splitting to two object to avoid "Stack too deep error"
+    // for having more than 16 local variables in the same scope.
+    ReserveConfigurationMap_ints intData;
+    ReserveConfigurationMap_bools boolData;
+  }
+
+  struct ReserveConfigurationMap_ints {
+    
+    uint256 Ltv;                     
+    uint256 LiquidationThreshold;   
+    uint256 LiquidationBonus;       
+    uint256 Decimals;                    
+    uint256 ReserveFactor;          
+    uint256 BorrowCap;              
+    uint256 SupplyCap;              
+    uint256 LiquidationProtocolFee;
+    uint256 EModeCategory;          
+    uint256 UnbackedMintCap;       
+    uint256 DebtCeiling; 
+  }
+
+  struct ReserveConfigurationMap_bools {
+    bool Active;                  
+    bool Frozen;                  
+    bool BorrowingEnabled;               
+    bool StableBorrowingEnabled;        
+    bool Paused;                  
+    bool BorrowableInIsolation; 
+    bool SiloedBorrowing;        
+    bool FlashLoanEnabled;
+  }
+
+  struct ReserveConfigurationMap_orig {
+    //bit 0-15: LTV
+    //bit 16-31: Liq. threshold
+    //bit 32-47: Liq. bonus
+    //bit 48-55: Decimals
+    //bit 56: reserve is active
+    //bit 57: reserve is frozen
+    //bit 58: borrowing is enabled
+    //bit 59: stable rate borrowing enabled
+    //bit 60: asset is paused
+    //bit 61: borrowing in isolation mode is enabled
+    //bit 62: siloed borrowing enabled
+    //bit 63: flashloaning enabled
+    //bit 64-79: reserve factor
+    //bit 80-115 borrow cap in whole tokens, borrowCap == 0 => no cap
+    //bit 116-151 supply cap in whole tokens, supplyCap == 0 => no cap
+    //bit 152-167 liquidation protocol fee
+    //bit 168-175 eMode category
+    //bit 176-211 unbacked mint cap in whole tokens, unbackedMintCap == 0 => minting disabled
+    //bit 212-251 debt ceiling for isolation mode with (ReserveConfiguration::DEBTCEILING_DECIMALS) decimals
+    //bit 252-255 unused
+
+    uint256 data;
+  }
+
+  struct UserConfigurationMap {
+      //uint256 data; //original data
+      bool isBorrowing0;
+      bool isBorrowing1;
+      bool isBorrowing2;
+      bool isUsingAsCollateral0;
+      bool isUsingAsCollateral1;
+      bool isUsingAsCollateral2;
+    }
+
+  struct UserConfigurationMap_noBV {
+      //uint256 data; //original data
+      bool[] isBorrowing;
+      bool[] isUsingAsCollateral;
+      uint16 borrowingCount;
+      uint16 usingAsCollateralCount;
+    }
+
+  struct UserConfigurationMap_original {
+    /**
+     * @dev Bitmap of the users collaterals and borrows. It is divided in pairs of bits, one pair per asset.
+     * The first bit indicates if an asset is used as collateral by the user, the second whether an
+     * asset is borrowed by the user.
+     */
+    uint256 data;
+  }
+
+  struct EModeCategory {
+    // each eMode category has a custom ltv and liquidation threshold
+    uint16 ltv;
+    uint16 liquidationThreshold;
+    uint16 liquidationBonus;
+    // each eMode category may or may not have a custom oracle to override the individual assets price oracles
+    address priceSource;
+    string label;
+  }
+
+  enum InterestRateMode {NONE, STABLE, VARIABLE}
+
+  struct ReserveCache {
+    uint256 currScaledVariableDebt;
+    uint256 nextScaledVariableDebt;
+    uint256 currPrincipalStableDebt;
+    uint256 currAvgStableBorrowRate;
+    uint256 currTotalStableDebt;
+    uint256 nextAvgStableBorrowRate;
+    uint256 nextTotalStableDebt;
+    uint256 currLiquidityIndex;
+    uint256 nextLiquidityIndex;
+    uint256 currVariableBorrowIndex;
+    uint256 nextVariableBorrowIndex;
+    uint256 currLiquidityRate;
+    uint256 currVariableBorrowRate;
+    uint256 reserveFactor;
+    ReserveConfigurationMap reserveConfiguration;
+    address aTokenAddress;
+    address stableDebtTokenAddress;
+    address variableDebtTokenAddress;
+    uint40 reserveLastUpdateTimestamp;
+    uint40 stableDebtLastUpdateTimestamp;
+  }
+
+  struct ExecuteLiquidationCallParams {
+    uint256 reservesCount;
+    uint256 debtToCover;
+    address collateralAsset;
+    address debtAsset;
+    address user;
+    bool receiveAToken;
+    address priceOracle;
+    uint8 userEModeCategory;
+    address priceOracleSentinel;
+  }
+
+  struct ExecuteSupplyParams {
+    address asset;
+    uint256 amount;
+    address onBehalfOf;
+    uint16 referralCode;
+  }
+
+  struct ExecuteBorrowParams {
+    address asset;
+    address user;
+    address onBehalfOf;
+    uint256 amount;
+    InterestRateMode interestRateMode;
+    uint16 referralCode;
+    bool releaseUnderlying;
+    uint256 maxStableRateBorrowSizePercent;
+    uint256 reservesCount;
+    address oracle;
+    uint8 userEModeCategory;
+    address priceOracleSentinel;
+  }
+
+  struct ExecuteRepayParams {
+    address asset;
+    uint256 amount;
+    InterestRateMode interestRateMode;
+    address onBehalfOf;
+    bool useATokens;
+  }
+
+  struct ExecuteWithdrawParams {
+    address asset;
+    uint256 amount;
+    address to;
+    uint256 reservesCount;
+    address oracle;
+    uint8 userEModeCategory;
+  }
+
+  struct ExecuteSetUserEModeParams {
+    uint256 reservesCount;
+    address oracle;
+    uint8 categoryId;
+  }
+
+  struct FinalizeTransferParams {
+    address asset;
+    address from;
+    address to;
+    uint256 amount;
+    uint256 balanceFromBefore;
+    uint256 balanceToBefore;
+    uint256 reservesCount;
+    address oracle;
+    uint8 fromEModeCategory;
+  }
+
+  struct FlashloanParams {
+    address receiverAddress;
+    address[] assets;
+    uint256[] amounts;
+    uint256[] interestRateModes;
+    address onBehalfOf;
+    bytes params;
+    uint16 referralCode;
+    uint256 flashLoanPremiumToProtocol;
+    uint256 flashLoanPremiumTotal;
+    uint256 maxStableRateBorrowSizePercent;
+    uint256 reservesCount;
+    address addressesProvider;
+    uint8 userEModeCategory;
+    bool isAuthorizedFlashBorrower;
+  }
+
+  struct FlashloanSimpleParams {
+    address receiverAddress;
+    address asset;
+    uint256 amount;
+    bytes params;
+    uint16 referralCode;
+    uint256 flashLoanPremiumToProtocol;
+    uint256 flashLoanPremiumTotal;
+  }
+
+  struct FlashLoanRepaymentParams {
+    uint256 amount;
+    uint256 totalPremium;
+    uint256 flashLoanPremiumToProtocol;
+    address asset;
+    address receiverAddress;
+    uint16 referralCode;
+  }
+
+  struct CalculateUserAccountDataParams {
+    UserConfigurationMap userConfig;
+    uint256 reservesCount;
+    address user;
+    address oracle;
+    uint8 userEModeCategory;
+  }
+
+  struct ValidateBorrowParams {
+    ReserveCache reserveCache;
+    UserConfigurationMap userConfig;
+    address asset;
+    address userAddress;
+    uint256 amount;
+    InterestRateMode interestRateMode;
+    uint256 maxStableLoanPercent;
+    uint256 reservesCount;
+    address oracle;
+    uint8 userEModeCategory;
+    address priceOracleSentinel;
+    bool isolationModeActive;
+    address isolationModeCollateralAddress;
+    uint256 isolationModeDebtCeiling;
+  }
+
+  struct ValidateLiquidationCallParams {
+    ReserveCache debtReserveCache;
+    uint256 totalDebt;
+    uint256 healthFactor;
+    address priceOracleSentinel;
+  }
+
+  struct CalculateInterestRatesParams {
+    uint256 unbacked;
+    uint256 liquidityAdded;
+    uint256 liquidityTaken;
+    uint256 totalStableDebt;
+    uint256 totalVariableDebt;
+    uint256 averageStableBorrowRate;
+    uint256 reserveFactor;
+    address reserve;
+    address aToken;
+  }
+
+  struct InitReserveParams {
+    address asset;
+    address aTokenAddress;
+    address stableDebtAddress;
+    address variableDebtAddress;
+    address interestRateStrategyAddress;
+    uint16 reservesCount;
+    uint16 maxNumberReserves;
+  }
+}
diff -ruN protocol/libraries/types/DataTypes_orig.sol protocol/libraries/types/DataTypes_orig.sol
--- protocol/libraries/types/DataTypes_orig.sol	1970-01-01 01:00:00
+++ protocol/libraries/types/DataTypes_orig.sol	2023-11-20 09:12:19
@@ -0,0 +1,265 @@
+// SPDX-License-Identifier: BUSL-1.1
+pragma solidity ^0.8.0;
+
+library DataTypes {
+  struct ReserveData {
+    //stores the reserve configuration
+    ReserveConfigurationMap configuration;
+    //the liquidity index. Expressed in ray
+    uint128 liquidityIndex;
+    //the current supply rate. Expressed in ray
+    uint128 currentLiquidityRate;
+    //variable borrow index. Expressed in ray
+    uint128 variableBorrowIndex;
+    //the current variable borrow rate. Expressed in ray
+    uint128 currentVariableBorrowRate;
+    //the current stable borrow rate. Expressed in ray
+    uint128 currentStableBorrowRate;
+    //timestamp of last update
+    uint40 lastUpdateTimestamp;
+    //the id of the reserve. Represents the position in the list of the active reserves
+    uint16 id;
+    //aToken address
+    address aTokenAddress;
+    //stableDebtToken address
+    address stableDebtTokenAddress;
+    //variableDebtToken address
+    address variableDebtTokenAddress;
+    //address of the interest rate strategy
+    address interestRateStrategyAddress;
+    //the current treasury balance, scaled
+    uint128 accruedToTreasury;
+    //the outstanding unbacked aTokens minted through the bridging feature
+    uint128 unbacked;
+    //the outstanding debt borrowed against this asset in isolation mode
+    uint128 isolationModeTotalDebt;
+  }
+
+  struct ReserveConfigurationMap {
+    //bit 0-15: LTV
+    //bit 16-31: Liq. threshold
+    //bit 32-47: Liq. bonus
+    //bit 48-55: Decimals
+    //bit 56: reserve is active
+    //bit 57: reserve is frozen
+    //bit 58: borrowing is enabled
+    //bit 59: stable rate borrowing enabled
+    //bit 60: asset is paused
+    //bit 61: borrowing in isolation mode is enabled
+    //bit 62: siloed borrowing enabled
+    //bit 63: flashloaning enabled
+    //bit 64-79: reserve factor
+    //bit 80-115 borrow cap in whole tokens, borrowCap == 0 => no cap
+    //bit 116-151 supply cap in whole tokens, supplyCap == 0 => no cap
+    //bit 152-167 liquidation protocol fee
+    //bit 168-175 eMode category
+    //bit 176-211 unbacked mint cap in whole tokens, unbackedMintCap == 0 => minting disabled
+    //bit 212-251 debt ceiling for isolation mode with (ReserveConfiguration::DEBT_CEILING_DECIMALS) decimals
+    //bit 252-255 unused
+
+    uint256 data;
+  }
+
+  struct UserConfigurationMap {
+    /**
+     * @dev Bitmap of the users collaterals and borrows. It is divided in pairs of bits, one pair per asset.
+     * The first bit indicates if an asset is used as collateral by the user, the second whether an
+     * asset is borrowed by the user.
+     */
+    uint256 data;
+  }
+
+  struct EModeCategory {
+    // each eMode category has a custom ltv and liquidation threshold
+    uint16 ltv;
+    uint16 liquidationThreshold;
+    uint16 liquidationBonus;
+    // each eMode category may or may not have a custom oracle to override the individual assets price oracles
+    address priceSource;
+    string label;
+  }
+
+  enum InterestRateMode {NONE, STABLE, VARIABLE}
+
+  struct ReserveCache {
+    uint256 currScaledVariableDebt;
+    uint256 nextScaledVariableDebt;
+    uint256 currPrincipalStableDebt;
+    uint256 currAvgStableBorrowRate;
+    uint256 currTotalStableDebt;
+    uint256 nextAvgStableBorrowRate;
+    uint256 nextTotalStableDebt;
+    uint256 currLiquidityIndex;
+    uint256 nextLiquidityIndex;
+    uint256 currVariableBorrowIndex;
+    uint256 nextVariableBorrowIndex;
+    uint256 currLiquidityRate;
+    uint256 currVariableBorrowRate;
+    uint256 reserveFactor;
+    ReserveConfigurationMap reserveConfiguration;
+    address aTokenAddress;
+    address stableDebtTokenAddress;
+    address variableDebtTokenAddress;
+    uint40 reserveLastUpdateTimestamp;
+    uint40 stableDebtLastUpdateTimestamp;
+  }
+
+  struct ExecuteLiquidationCallParams {
+    uint256 reservesCount;
+    uint256 debtToCover;
+    address collateralAsset;
+    address debtAsset;
+    address user;
+    bool receiveAToken;
+    address priceOracle;
+    uint8 userEModeCategory;
+    address priceOracleSentinel;
+  }
+
+  struct ExecuteSupplyParams {
+    address asset;
+    uint256 amount;
+    address onBehalfOf;
+    uint16 referralCode;
+  }
+
+  struct ExecuteBorrowParams {
+    address asset;
+    address user;
+    address onBehalfOf;
+    uint256 amount;
+    InterestRateMode interestRateMode;
+    uint16 referralCode;
+    bool releaseUnderlying;
+    uint256 maxStableRateBorrowSizePercent;
+    uint256 reservesCount;
+    address oracle;
+    uint8 userEModeCategory;
+    address priceOracleSentinel;
+  }
+
+  struct ExecuteRepayParams {
+    address asset;
+    uint256 amount;
+    InterestRateMode interestRateMode;
+    address onBehalfOf;
+    bool useATokens;
+  }
+
+  struct ExecuteWithdrawParams {
+    address asset;
+    uint256 amount;
+    address to;
+    uint256 reservesCount;
+    address oracle;
+    uint8 userEModeCategory;
+  }
+
+  struct ExecuteSetUserEModeParams {
+    uint256 reservesCount;
+    address oracle;
+    uint8 categoryId;
+  }
+
+  struct FinalizeTransferParams {
+    address asset;
+    address from;
+    address to;
+    uint256 amount;
+    uint256 balanceFromBefore;
+    uint256 balanceToBefore;
+    uint256 reservesCount;
+    address oracle;
+    uint8 fromEModeCategory;
+  }
+
+  struct FlashloanParams {
+    address receiverAddress;
+    address[] assets;
+    uint256[] amounts;
+    uint256[] interestRateModes;
+    address onBehalfOf;
+    bytes params;
+    uint16 referralCode;
+    uint256 flashLoanPremiumToProtocol;
+    uint256 flashLoanPremiumTotal;
+    uint256 maxStableRateBorrowSizePercent;
+    uint256 reservesCount;
+    address addressesProvider;
+    uint8 userEModeCategory;
+    bool isAuthorizedFlashBorrower;
+  }
+
+  struct FlashloanSimpleParams {
+    address receiverAddress;
+    address asset;
+    uint256 amount;
+    bytes params;
+    uint16 referralCode;
+    uint256 flashLoanPremiumToProtocol;
+    uint256 flashLoanPremiumTotal;
+  }
+
+  struct FlashLoanRepaymentParams {
+    uint256 amount;
+    uint256 totalPremium;
+    uint256 flashLoanPremiumToProtocol;
+    address asset;
+    address receiverAddress;
+    uint16 referralCode;
+  }
+
+  struct CalculateUserAccountDataParams {
+    UserConfigurationMap userConfig;
+    uint256 reservesCount;
+    address user;
+    address oracle;
+    uint8 userEModeCategory;
+  }
+
+  struct ValidateBorrowParams {
+    ReserveCache reserveCache;
+    UserConfigurationMap userConfig;
+    address asset;
+    address userAddress;
+    uint256 amount;
+    InterestRateMode interestRateMode;
+    uint256 maxStableLoanPercent;
+    uint256 reservesCount;
+    address oracle;
+    uint8 userEModeCategory;
+    address priceOracleSentinel;
+    bool isolationModeActive;
+    address isolationModeCollateralAddress;
+    uint256 isolationModeDebtCeiling;
+  }
+
+  struct ValidateLiquidationCallParams {
+    ReserveCache debtReserveCache;
+    uint256 totalDebt;
+    uint256 healthFactor;
+    address priceOracleSentinel;
+  }
+
+  struct CalculateInterestRatesParams {
+    uint256 unbacked;
+    uint256 liquidityAdded;
+    uint256 liquidityTaken;
+    uint256 totalStableDebt;
+    uint256 totalVariableDebt;
+    uint256 averageStableBorrowRate;
+    uint256 reserveFactor;
+    address reserve;
+    address aToken;
+  }
+
+  struct InitReserveParams {
+    address asset;
+    address aTokenAddress;
+    address stableDebtAddress;
+    address variableDebtAddress;
+    address interestRateStrategyAddress;
+    uint16 reservesCount;
+    uint16 maxNumberReserves;
+  }
+}
diff -ruN protocol/tokenization/AToken.sol protocol/tokenization/AToken.sol
--- protocol/tokenization/AToken.sol	2023-09-15 08:31:43
+++ protocol/tokenization/AToken.sol	2023-11-20 09:16:54
@@ -70,16 +70,16 @@
 
     _domainSeparator = _calculateDomainSeparator();
 
-    emit Initialized(
-      underlyingAsset,
-      address(POOL),
-      treasury,
-      address(incentivesController),
-      aTokenDecimals,
-      aTokenName,
-      aTokenSymbol,
-      params
-    );
+    // emit Initialized(
+    //   underlyingAsset,
+    //   address(POOL),
+    //   treasury,
+    //   address(incentivesController),
+    //   aTokenDecimals,
+    //   aTokenName,
+    //   aTokenSymbol,
+    //   params
+    // );
   }
 
   /// @inheritdoc IAToken
@@ -252,5 +252,11 @@
   function rescueTokens(address token, address to, uint256 amount) external override onlyPoolAdmin {
     require(token != _underlyingAsset, Errors.UNDERLYING_CANNOT_BE_RESCUED);
     IERC20(token).safeTransfer(to, amount);
+  }
+
+  function superBalance(
+    address user
+  ) public view returns (uint256) {
+      return super.balanceOf(user);
   }
 }
diff -ruN protocol/tokenization/AToken.sol.orig protocol/tokenization/AToken.sol.orig
--- protocol/tokenization/AToken.sol.orig	1970-01-01 01:00:00
+++ protocol/tokenization/AToken.sol.orig	2023-10-31 21:09:28
@@ -0,0 +1,256 @@
+// SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.10;
+
+import {IERC20} from '../../dependencies/openzeppelin/contracts/IERC20.sol';
+import {GPv2SafeERC20} from '../../dependencies/gnosis/contracts/GPv2SafeERC20.sol';
+import {SafeCast} from '../../dependencies/openzeppelin/contracts/SafeCast.sol';
+import {VersionedInitializable} from '../libraries/aave-upgradeability/VersionedInitializable.sol';
+import {Errors} from '../libraries/helpers/Errors.sol';
+import {WadRayMath} from '../libraries/math/WadRayMath.sol';
+import {IPool} from '../../interfaces/IPool.sol';
+import {IAToken} from '../../interfaces/IAToken.sol';
+import {IAaveIncentivesController} from '../../interfaces/IAaveIncentivesController.sol';
+import {IInitializableAToken} from '../../interfaces/IInitializableAToken.sol';
+import {ScaledBalanceTokenBase} from './base/ScaledBalanceTokenBase.sol';
+import {IncentivizedERC20} from './base/IncentivizedERC20.sol';
+import {EIP712Base} from './base/EIP712Base.sol';
+
+/**
+ * @title Aave ERC20 AToken
+ * @author Aave
+ * @notice Implementation of the interest bearing token for the Aave protocol
+ */
+contract AToken is VersionedInitializable, ScaledBalanceTokenBase, EIP712Base, IAToken {
+  using WadRayMath for uint256;
+  using SafeCast for uint256;
+  using GPv2SafeERC20 for IERC20;
+
+  bytes32 public constant PERMIT_TYPEHASH =
+    keccak256('Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)');
+
+  uint256 public constant ATOKEN_REVISION = 0x1;
+
+  address internal _treasury;
+  address internal _underlyingAsset;
+
+  /// @inheritdoc VersionedInitializable
+  function getRevision() internal pure virtual override returns (uint256) {
+    return ATOKEN_REVISION;
+  }
+
+  /**
+   * @dev Constructor.
+   * @param pool The address of the Pool contract
+   */
+  constructor(
+    IPool pool
+  ) ScaledBalanceTokenBase(pool, 'ATOKEN_IMPL', 'ATOKEN_IMPL', 0) EIP712Base() {
+    // Intentionally left blank
+  }
+
+  /// @inheritdoc IInitializableAToken
+  function initialize(
+    IPool initializingPool,
+    address treasury,
+    address underlyingAsset,
+    IAaveIncentivesController incentivesController,
+    uint8 aTokenDecimals,
+    string calldata aTokenName,
+    string calldata aTokenSymbol,
+    bytes calldata params
+  ) public virtual override initializer {
+    require(initializingPool == POOL, Errors.POOL_ADDRESSES_DO_NOT_MATCH);
+    _setName(aTokenName);
+    _setSymbol(aTokenSymbol);
+    _setDecimals(aTokenDecimals);
+
+    _treasury = treasury;
+    _underlyingAsset = underlyingAsset;
+    _incentivesController = incentivesController;
+
+    _domainSeparator = _calculateDomainSeparator();
+
+    emit Initialized(
+      underlyingAsset,
+      address(POOL),
+      treasury,
+      address(incentivesController),
+      aTokenDecimals,
+      aTokenName,
+      aTokenSymbol,
+      params
+    );
+  }
+
+  /// @inheritdoc IAToken
+  function mint(
+    address caller,
+    address onBehalfOf,
+    uint256 amount,
+    uint256 index
+  ) external virtual override onlyPool returns (bool) {
+    return _mintScaled(caller, onBehalfOf, amount, index);
+  }
+
+  /// @inheritdoc IAToken
+  function burn(
+    address from,
+    address receiverOfUnderlying,
+    uint256 amount,
+    uint256 index
+  ) external virtual override onlyPool {
+    _burnScaled(from, receiverOfUnderlying, amount, index);
+    if (receiverOfUnderlying != address(this)) {
+      IERC20(_underlyingAsset).safeTransfer(receiverOfUnderlying, amount);
+    }
+  }
+
+  /// @inheritdoc IAToken
+  function mintToTreasury(uint256 amount, uint256 index) external virtual override onlyPool {
+    if (amount == 0) {
+      return;
+    }
+    _mintScaled(address(POOL), _treasury, amount, index);
+  }
+
+  /// @inheritdoc IAToken
+  function transferOnLiquidation(
+    address from,
+    address to,
+    uint256 value
+  ) external virtual override onlyPool {
+    // Being a normal transfer, the Transfer() and BalanceTransfer() are emitted
+    // so no need to emit a specific event here
+    _transfer(from, to, value, false);
+  }
+
+  /// @inheritdoc IERC20
+  function balanceOf(
+    address user
+  ) public view virtual override(IncentivizedERC20, IERC20) returns (uint256) {
+    return super.balanceOf(user).rayMul(POOL.getReserveNormalizedIncome(_underlyingAsset));
+  }
+
+  /// @inheritdoc IERC20
+  function totalSupply() public view virtual override(IncentivizedERC20, IERC20) returns (uint256) {
+    uint256 currentSupplyScaled = super.totalSupply();
+
+    if (currentSupplyScaled == 0) {
+      return 0;
+    }
+
+    return currentSupplyScaled.rayMul(POOL.getReserveNormalizedIncome(_underlyingAsset));
+  }
+
+  /// @inheritdoc IAToken
+  function RESERVE_TREASURY_ADDRESS() external view override returns (address) {
+    return _treasury;
+  }
+
+  /// @inheritdoc IAToken
+  function UNDERLYING_ASSET_ADDRESS() external view override returns (address) {
+    return _underlyingAsset;
+  }
+
+  /// @inheritdoc IAToken
+  function transferUnderlyingTo(address target, uint256 amount) external virtual override onlyPool {
+    IERC20(_underlyingAsset).safeTransfer(target, amount);
+  }
+
+  /// @inheritdoc IAToken
+  function handleRepayment(
+    address user,
+    address onBehalfOf,
+    uint256 amount
+  ) external virtual override onlyPool {
+    // Intentionally left blank
+  }
+
+  /// @inheritdoc IAToken
+  function permit(
+    address owner,
+    address spender,
+    uint256 value,
+    uint256 deadline,
+    uint8 v,
+    bytes32 r,
+    bytes32 s
+  ) external override {
+    require(owner != address(0), Errors.ZERO_ADDRESS_NOT_VALID);
+    //solium-disable-next-line
+    require(block.timestamp <= deadline, Errors.INVALID_EXPIRATION);
+    uint256 currentValidNonce = _nonces[owner];
+    bytes32 digest = keccak256(
+      abi.encodePacked(
+        '\x19\x01',
+        DOMAIN_SEPARATOR(),
+        keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, currentValidNonce, deadline))
+      )
+    );
+    require(owner == ecrecover(digest, v, r, s), Errors.INVALID_SIGNATURE);
+    _nonces[owner] = currentValidNonce + 1;
+    _approve(owner, spender, value);
+  }
+
+  /**
+   * @notice Transfers the aTokens between two users. Validates the transfer
+   * (ie checks for valid HF after the transfer) if required
+   * @param from The source address
+   * @param to The destination address
+   * @param amount The amount getting transferred
+   * @param validate True if the transfer needs to be validated, false otherwise
+   */
+  function _transfer(address from, address to, uint256 amount, bool validate) internal virtual {
+    address underlyingAsset = _underlyingAsset;
+
+    uint256 index = POOL.getReserveNormalizedIncome(underlyingAsset);
+
+    uint256 fromBalanceBefore = super.balanceOf(from).rayMul(index);
+    uint256 toBalanceBefore = super.balanceOf(to).rayMul(index);
+
+    super._transfer(from, to, amount, index);
+
+    if (validate) {
+      POOL.finalizeTransfer(underlyingAsset, from, to, amount, fromBalanceBefore, toBalanceBefore);
+    }
+
+    emit BalanceTransfer(from, to, amount.rayDiv(index), index);
+  }
+
+  /**
+   * @notice Overrides the parent _transfer to force validated transfer() and transferFrom()
+   * @param from The source address
+   * @param to The destination address
+   * @param amount The amount getting transferred
+   */
+  function _transfer(address from, address to, uint128 amount) internal virtual override {
+    _transfer(from, to, amount, true);
+  }
+
+  /**
+   * @dev Overrides the base function to fully implement IAToken
+   * @dev see `EIP712Base.DOMAIN_SEPARATOR()` for more detailed documentation
+   */
+  function DOMAIN_SEPARATOR() public view override(IAToken, EIP712Base) returns (bytes32) {
+    return super.DOMAIN_SEPARATOR();
+  }
+
+  /**
+   * @dev Overrides the base function to fully implement IAToken
+   * @dev see `EIP712Base.nonces()` for more detailed documentation
+   */
+  function nonces(address owner) public view override(IAToken, EIP712Base) returns (uint256) {
+    return super.nonces(owner);
+  }
+
+  /// @inheritdoc EIP712Base
+  function _EIP712BaseId() internal view override returns (string memory) {
+    return name();
+  }
+
+  /// @inheritdoc IAToken
+  function rescueTokens(address token, address to, uint256 amount) external override onlyPoolAdmin {
+    require(token != _underlyingAsset, Errors.UNDERLYING_CANNOT_BE_RESCUED);
+    IERC20(token).safeTransfer(to, amount);
+  }
+}
diff -ruN protocol/tokenization/StableDebtToken.sol protocol/tokenization/StableDebtToken.sol
--- protocol/tokenization/StableDebtToken.sol	2023-09-15 08:31:43
+++ protocol/tokenization/StableDebtToken.sol	2023-10-31 21:09:28
@@ -306,7 +306,7 @@
    * @param avgRate The average rate at which the total supply increases
    * @return The debt balance of the user since the last burn/mint action
    */
-  function _calcTotalSupply(uint256 avgRate) internal view returns (uint256) {
+  function _calcTotalSupply(uint256 avgRate) internal virtual view returns (uint256) {
     uint256 principalSupply = super.totalSupply();
 
     if (principalSupply == 0) {
diff -ruN protocol/tokenization/StableDebtToken.sol.orig protocol/tokenization/StableDebtToken.sol.orig
--- protocol/tokenization/StableDebtToken.sol.orig	1970-01-01 01:00:00
+++ protocol/tokenization/StableDebtToken.sol.orig	2023-10-31 21:09:28
@@ -0,0 +1,388 @@
+// SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.10;
+
+import {IERC20} from '../../dependencies/openzeppelin/contracts/IERC20.sol';
+import {VersionedInitializable} from '../libraries/aave-upgradeability/VersionedInitializable.sol';
+import {MathUtils} from '../libraries/math/MathUtils.sol';
+import {WadRayMath} from '../libraries/math/WadRayMath.sol';
+import {Errors} from '../libraries/helpers/Errors.sol';
+import {IAaveIncentivesController} from '../../interfaces/IAaveIncentivesController.sol';
+import {IInitializableDebtToken} from '../../interfaces/IInitializableDebtToken.sol';
+import {IStableDebtToken} from '../../interfaces/IStableDebtToken.sol';
+import {IPool} from '../../interfaces/IPool.sol';
+import {EIP712Base} from './base/EIP712Base.sol';
+import {DebtTokenBase} from './base/DebtTokenBase.sol';
+import {IncentivizedERC20} from './base/IncentivizedERC20.sol';
+import {SafeCast} from '../../dependencies/openzeppelin/contracts/SafeCast.sol';
+
+/**
+ * @title StableDebtToken
+ * @author Aave
+ * @notice Implements a stable debt token to track the borrowing positions of users
+ * at stable rate mode
+ * @dev Transfer and approve functionalities are disabled since its a non-transferable token
+ */
+contract StableDebtToken is DebtTokenBase, IncentivizedERC20, IStableDebtToken {
+  using WadRayMath for uint256;
+  using SafeCast for uint256;
+
+  uint256 public constant DEBT_TOKEN_REVISION = 0x1;
+
+  // Map of users address and the timestamp of their last update (userAddress => lastUpdateTimestamp)
+  mapping(address => uint40) internal _timestamps;
+
+  uint128 internal _avgStableRate;
+
+  // Timestamp of the last update of the total supply
+  uint40 internal _totalSupplyTimestamp;
+
+  /**
+   * @dev Constructor.
+   * @param pool The address of the Pool contract
+   */
+  constructor(
+    IPool pool
+  ) DebtTokenBase() IncentivizedERC20(pool, 'STABLE_DEBT_TOKEN_IMPL', 'STABLE_DEBT_TOKEN_IMPL', 0) {
+    // Intentionally left blank
+  }
+
+  /// @inheritdoc IInitializableDebtToken
+  function initialize(
+    IPool initializingPool,
+    address underlyingAsset,
+    IAaveIncentivesController incentivesController,
+    uint8 debtTokenDecimals,
+    string memory debtTokenName,
+    string memory debtTokenSymbol,
+    bytes calldata params
+  ) external override initializer {
+    require(initializingPool == POOL, Errors.POOL_ADDRESSES_DO_NOT_MATCH);
+    _setName(debtTokenName);
+    _setSymbol(debtTokenSymbol);
+    _setDecimals(debtTokenDecimals);
+
+    _underlyingAsset = underlyingAsset;
+    _incentivesController = incentivesController;
+
+    _domainSeparator = _calculateDomainSeparator();
+
+    emit Initialized(
+      underlyingAsset,
+      address(POOL),
+      address(incentivesController),
+      debtTokenDecimals,
+      debtTokenName,
+      debtTokenSymbol,
+      params
+    );
+  }
+
+  /// @inheritdoc VersionedInitializable
+  function getRevision() internal pure virtual override returns (uint256) {
+    return DEBT_TOKEN_REVISION;
+  }
+
+  /// @inheritdoc IStableDebtToken
+  function getAverageStableRate() external view virtual override returns (uint256) {
+    return _avgStableRate;
+  }
+
+  /// @inheritdoc IStableDebtToken
+  function getUserLastUpdated(address user) external view virtual override returns (uint40) {
+    return _timestamps[user];
+  }
+
+  /// @inheritdoc IStableDebtToken
+  function getUserStableRate(address user) external view virtual override returns (uint256) {
+    return _userState[user].additionalData;
+  }
+
+  /// @inheritdoc IERC20
+  function balanceOf(address account) public view virtual override returns (uint256) {
+    uint256 accountBalance = super.balanceOf(account);
+    uint256 stableRate = _userState[account].additionalData;
+    if (accountBalance == 0) {
+      return 0;
+    }
+    uint256 cumulatedInterest = MathUtils.calculateCompoundedInterest(
+      stableRate,
+      _timestamps[account]
+    );
+    return accountBalance.rayMul(cumulatedInterest);
+  }
+
+  struct MintLocalVars {
+    uint256 previousSupply;
+    uint256 nextSupply;
+    uint256 amountInRay;
+    uint256 currentStableRate;
+    uint256 nextStableRate;
+    uint256 currentAvgStableRate;
+  }
+
+  /// @inheritdoc IStableDebtToken
+  function mint(
+    address user,
+    address onBehalfOf,
+    uint256 amount,
+    uint256 rate
+  ) external virtual override onlyPool returns (bool, uint256, uint256) {
+    MintLocalVars memory vars;
+
+    if (user != onBehalfOf) {
+      _decreaseBorrowAllowance(onBehalfOf, user, amount);
+    }
+
+    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(onBehalfOf);
+
+    vars.previousSupply = totalSupply();
+    vars.currentAvgStableRate = _avgStableRate;
+    vars.nextSupply = _totalSupply = vars.previousSupply + amount;
+
+    vars.amountInRay = amount.wadToRay();
+
+    vars.currentStableRate = _userState[onBehalfOf].additionalData;
+    vars.nextStableRate = (vars.currentStableRate.rayMul(currentBalance.wadToRay()) +
+      vars.amountInRay.rayMul(rate)).rayDiv((currentBalance + amount).wadToRay());
+
+    _userState[onBehalfOf].additionalData = vars.nextStableRate.toUint128();
+
+    //solium-disable-next-line
+    _totalSupplyTimestamp = _timestamps[onBehalfOf] = uint40(block.timestamp);
+
+    // Calculates the updated average stable rate
+    vars.currentAvgStableRate = _avgStableRate = (
+      (vars.currentAvgStableRate.rayMul(vars.previousSupply.wadToRay()) +
+        rate.rayMul(vars.amountInRay)).rayDiv(vars.nextSupply.wadToRay())
+    ).toUint128();
+
+    uint256 amountToMint = amount + balanceIncrease;
+    _mint(onBehalfOf, amountToMint, vars.previousSupply);
+
+    emit Transfer(address(0), onBehalfOf, amountToMint);
+    emit Mint(
+      user,
+      onBehalfOf,
+      amountToMint,
+      currentBalance,
+      balanceIncrease,
+      vars.nextStableRate,
+      vars.currentAvgStableRate,
+      vars.nextSupply
+    );
+
+    return (currentBalance == 0, vars.nextSupply, vars.currentAvgStableRate);
+  }
+
+  /// @inheritdoc IStableDebtToken
+  function burn(
+    address from,
+    uint256 amount
+  ) external virtual override onlyPool returns (uint256, uint256) {
+    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(from);
+
+    uint256 previousSupply = totalSupply();
+    uint256 nextAvgStableRate = 0;
+    uint256 nextSupply = 0;
+    uint256 userStableRate = _userState[from].additionalData;
+
+    // Since the total supply and each single user debt accrue separately,
+    // there might be accumulation errors so that the last borrower repaying
+    // might actually try to repay more than the available debt supply.
+    // In this case we simply set the total supply and the avg stable rate to 0
+    if (previousSupply <= amount) {
+      _avgStableRate = 0;
+      _totalSupply = 0;
+    } else {
+      nextSupply = _totalSupply = previousSupply - amount;
+      uint256 firstTerm = uint256(_avgStableRate).rayMul(previousSupply.wadToRay());
+      uint256 secondTerm = userStableRate.rayMul(amount.wadToRay());
+
+      // For the same reason described above, when the last user is repaying it might
+      // happen that user rate * user balance > avg rate * total supply. In that case,
+      // we simply set the avg rate to 0
+      if (secondTerm >= firstTerm) {
+        nextAvgStableRate = _totalSupply = _avgStableRate = 0;
+      } else {
+        nextAvgStableRate = _avgStableRate = (
+          (firstTerm - secondTerm).rayDiv(nextSupply.wadToRay())
+        ).toUint128();
+      }
+    }
+
+    if (amount == currentBalance) {
+      _userState[from].additionalData = 0;
+      _timestamps[from] = 0;
+    } else {
+      //solium-disable-next-line
+      _timestamps[from] = uint40(block.timestamp);
+    }
+    //solium-disable-next-line
+    _totalSupplyTimestamp = uint40(block.timestamp);
+
+    if (balanceIncrease > amount) {
+      uint256 amountToMint = balanceIncrease - amount;
+      _mint(from, amountToMint, previousSupply);
+      emit Transfer(address(0), from, amountToMint);
+      emit Mint(
+        from,
+        from,
+        amountToMint,
+        currentBalance,
+        balanceIncrease,
+        userStableRate,
+        nextAvgStableRate,
+        nextSupply
+      );
+    } else {
+      uint256 amountToBurn = amount - balanceIncrease;
+      _burn(from, amountToBurn, previousSupply);
+      emit Transfer(from, address(0), amountToBurn);
+      emit Burn(from, amountToBurn, currentBalance, balanceIncrease, nextAvgStableRate, nextSupply);
+    }
+
+    return (nextSupply, nextAvgStableRate);
+  }
+
+  /**
+   * @notice Calculates the increase in balance since the last user interaction
+   * @param user The address of the user for which the interest is being accumulated
+   * @return The previous principal balance
+   * @return The new principal balance
+   * @return The balance increase
+   */
+  function _calculateBalanceIncrease(
+    address user
+  ) internal view returns (uint256, uint256, uint256) {
+    uint256 previousPrincipalBalance = super.balanceOf(user);
+
+    if (previousPrincipalBalance == 0) {
+      return (0, 0, 0);
+    }
+
+    uint256 newPrincipalBalance = balanceOf(user);
+
+    return (
+      previousPrincipalBalance,
+      newPrincipalBalance,
+      newPrincipalBalance - previousPrincipalBalance
+    );
+  }
+
+  /// @inheritdoc IStableDebtToken
+  function getSupplyData() external view override returns (uint256, uint256, uint256, uint40) {
+    uint256 avgRate = _avgStableRate;
+    return (super.totalSupply(), _calcTotalSupply(avgRate), avgRate, _totalSupplyTimestamp);
+  }
+
+  /// @inheritdoc IStableDebtToken
+  function getTotalSupplyAndAvgRate() external view override returns (uint256, uint256) {
+    uint256 avgRate = _avgStableRate;
+    return (_calcTotalSupply(avgRate), avgRate);
+  }
+
+  /// @inheritdoc IERC20
+  function totalSupply() public view virtual override returns (uint256) {
+    return _calcTotalSupply(_avgStableRate);
+  }
+
+  /// @inheritdoc IStableDebtToken
+  function getTotalSupplyLastUpdated() external view override returns (uint40) {
+    return _totalSupplyTimestamp;
+  }
+
+  /// @inheritdoc IStableDebtToken
+  function principalBalanceOf(address user) external view virtual override returns (uint256) {
+    return super.balanceOf(user);
+  }
+
+  /// @inheritdoc IStableDebtToken
+  function UNDERLYING_ASSET_ADDRESS() external view override returns (address) {
+    return _underlyingAsset;
+  }
+
+  /**
+   * @notice Calculates the total supply
+   * @param avgRate The average rate at which the total supply increases
+   * @return The debt balance of the user since the last burn/mint action
+   */
+  function _calcTotalSupply(uint256 avgRate) internal view returns (uint256) {
+    uint256 principalSupply = super.totalSupply();
+
+    if (principalSupply == 0) {
+      return 0;
+    }
+
+    uint256 cumulatedInterest = MathUtils.calculateCompoundedInterest(
+      avgRate,
+      _totalSupplyTimestamp
+    );
+
+    return principalSupply.rayMul(cumulatedInterest);
+  }
+
+  /**
+   * @notice Mints stable debt tokens to a user
+   * @param account The account receiving the debt tokens
+   * @param amount The amount being minted
+   * @param oldTotalSupply The total supply before the minting event
+   */
+  function _mint(address account, uint256 amount, uint256 oldTotalSupply) internal {
+    uint128 castAmount = amount.toUint128();
+    uint128 oldAccountBalance = _userState[account].balance;
+    _userState[account].balance = oldAccountBalance + castAmount;
+
+    if (address(_incentivesController) != address(0)) {
+      _incentivesController.handleAction(account, oldTotalSupply, oldAccountBalance);
+    }
+  }
+
+  /**
+   * @notice Burns stable debt tokens of a user
+   * @param account The user getting his debt burned
+   * @param amount The amount being burned
+   * @param oldTotalSupply The total supply before the burning event
+   */
+  function _burn(address account, uint256 amount, uint256 oldTotalSupply) internal {
+    uint128 castAmount = amount.toUint128();
+    uint128 oldAccountBalance = _userState[account].balance;
+    _userState[account].balance = oldAccountBalance - castAmount;
+
+    if (address(_incentivesController) != address(0)) {
+      _incentivesController.handleAction(account, oldTotalSupply, oldAccountBalance);
+    }
+  }
+
+  /// @inheritdoc EIP712Base
+  function _EIP712BaseId() internal view override returns (string memory) {
+    return name();
+  }
+
+  /**
+   * @dev Being non transferrable, the debt token does not implement any of the
+   * standard ERC20 functions for transfer and allowance.
+   */
+  function transfer(address, uint256) external virtual override returns (bool) {
+    revert(Errors.OPERATION_NOT_SUPPORTED);
+  }
+
+  function allowance(address, address) external view virtual override returns (uint256) {
+    revert(Errors.OPERATION_NOT_SUPPORTED);
+  }
+
+  function approve(address, uint256) external virtual override returns (bool) {
+    revert(Errors.OPERATION_NOT_SUPPORTED);
+  }
+
+  function transferFrom(address, address, uint256) external virtual override returns (bool) {
+    revert(Errors.OPERATION_NOT_SUPPORTED);
+  }
+
+  function increaseAllowance(address, uint256) external virtual override returns (bool) {
+    revert(Errors.OPERATION_NOT_SUPPORTED);
+  }
+
+  function decreaseAllowance(address, uint256) external virtual override returns (bool) {
+    revert(Errors.OPERATION_NOT_SUPPORTED);
+  }
+}
